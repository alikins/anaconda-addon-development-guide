<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Anaconda_Addon_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<article status="draft">
    <xi:include href="Article_Info.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
    <section id="section_introduction">
      <title>Introduction</title>
      <para>
        The Anaconda<indexterm id="idx_anaconda"> <primary>Anaconda</primary>
        </indexterm> is the operating system installer (OS) used in &FEDORA;,
        &RHEL; and their derivatives. From a closer look it is a set of Python
        modules and scripts together with some additional files like Gtk widgets
        (written in C), systemd units and dracut libraries. Altogether they form
        a tool that allows user to set parameters of the resulting (target)
        system and then set such system up on a machine. The final installation
        process has four major steps:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            installation destination preparation (usually disk partitioning)
          </para>
        </listitem>
        <listitem>
          <para>
            package and data installation
          </para>
        </listitem>
        <listitem>
          <para>
            boot loader installation and configuration
          </para>
        </listitem>
        <listitem>
          <para>
            configuration of the newly installed system
          </para>
        </listitem>
      </itemizedlist>

      <para>
        There are three ways how the user can set parameters for the target
        system (and in some cases also for the installation process). The most
        commonly used one is the graphical user interface (GUI) <indexterm
        id="idx_gui"> <primary>GUI</primary> </indexterm> which should cover all
        common use cases and should be clear and easily understandable even for
        non-advanced users. Although Anaconda supports also installation over
        VNC <indexterm id="idx_vnc"> <primary>VNC</primary> </indexterm> there
        are some corner cases where a textual interface is needed and some of
        these cases are installations over serial consoles on "exotic" pieces of
        hardware. For this reason Anaconda also has a textual user interface
        (TUI) <indexterm id="idx_tui"> <primary>TUI</primary> </indexterm> that
        works basically the same way as a black only line printer (because of
        the various serial consoles not supporting cursor movement, colors and
        other "advanced" features). Text mode installation implements only most
        important features of the graphical installation and usually needs to be
        combined with the command line arguments passed to the Anaconda
        installer because it doesn't provide all options GUI provides. The third
        way to set the installation parameters and the most advanced one is a
        kickstart file. <indexterm id="idx_kickstart">
        <primary>kickstart</primary> </indexterm> It is a simple file with
        command-like syntax which can contain data driving the installation
        process that then runs automatically unless the kickstart file doesn't
        contain all data needed in which case the UI asks user about the missing
        pieces. More info about kickstarts can be found at <ulink
        url="http://fedoraproject.org/wiki/Anaconda/Kickstart">the
        Anaconda/Kickstart wiki page</ulink>. Addons related kickstart
        specifications are covered in <xref linkend="section_addon_structure"/>.
        Important fact is that opposed to the TUI which is not a full-featured
        mode of the installation, kickstart installation provides the highest
        number of configuration options. The golden rule is that everything has
        to be supported in kickstart first. Then GUI and TUI pieces can come
        supporting subsets of configuration options provided in kickstart that
        allow to keep user interface (UI) clear and non-confusing. All in all
        Anaconda has to be simple but at the same time complex which is always
        hard to achieve.
      </para>

      <para>
        As it is probably obvious there are many things that need to be happen
        during the installation process. And for many teams and individuals it
        seems to be a good idea to add more things to the OS installer so that
        the target system can be pre-configured before it is run for the first
        time. On one hand the installation environment is quite specific and
        commonly used tools are usually not ready to work in it, but on the
        other hand once something can be configured via kickstart multiple
        systems with the same configuration can be installed easily. However the
        more code in the installer, the more bugs it contains. Moreover the
        maintenance becomes harder and harder with every new functionality and
        it is harder and harder to follow changes in so many areas. So because
        of all these reasons it was decided that when doing a major rewrite of
        the Anaconda installer, support for addons <indexterm id="idx_addon">
        <primary>addon</primary> </indexterm> has to be added to allow other
        teams and individuals participate with their pieces of code developed
        and maintained by them as experts in their particular areas of
        interest. This guide should be one of the tools lowering the barrier to
        understanding how the Anaconda installer works and looks like internally
        and how its functionality can be extended with an addon.
      </para>

      <para>
        Traditionally the first boot of the newly installed system is also being
        considered to be a part of the installation procedure as some
        configuration of the system (e.g. users creation) is taking place at
        that point. For many years there has been a graphical tool called <ulink
        url="http://fedoraproject.org/wiki/FirstBoot">Firstboot</ulink>
        <indexterm id="idx_firstboot"><primary>Firstboot</primary></indexterm>
        that has helped user configure some aspects of the newly installed
        system. Problem with Firstboot is that it is using Gtk2 and pygtk module
        which are both no longer developed so it needs a rewrite too. Since the
        goal was to provide all options from the Firstboot already during the
        installation process it was obvious that the rewritten Firstboot should
        be sharing the code with the Anaconda installer.

        <footnote>
          <para>
            At the same time it was obvious that the old Firstboot had to be
            kept working because of the third-party modules written for it.
          </para>
        </footnote>

        That is how a new tool called <ulink
        url="http://fedoraproject.org/wiki/Features/NewFirstboot"> Initial
        Setup</ulink> <indexterm id="idx_is"><primary>Initial Setup</primary>
        </indexterm> was born. It is reusing a lot of code from the Anaconda
        installer, it has the same model and design as the installer and it
        reads data produced by the installer to show values set during the
        installation process. And the great thing is that only a little is
        needed for an Anaconda addon to become an Initial Setup addon. We will
        get to this in detail in <xref linkend="section_writing_addon"/>.
      </para>

      <para>
        Some additional information about the Anaconda installer can be found at
        <ulink url="http://fedoraproject.org/wiki/Anaconda">the Anaconda wiki
        page</ulink> and additional info about the rewrite can be found at
        <ulink url="https://fedoraproject.org/wiki/Anaconda/NewInstaller">the
        Anaconda/NewInstaller wiki page</ulink>.
      </para>
    </section>

    <section id="section_architecture">
      <title>Architecture</title>
      <para>
        As has been already mentioned, the Anaconda installer is a set of python
        modules and scripts. It of course also uses a lot of external packages
        and libraries some of which were originally created specifically for the
        needs of the installer. Major components of the whole tool are the
        following packages: <package>pykickstart</package>, <indexterm
        id="idx_pykickstart"> <primary>pykickstart</primary> </indexterm>
        <package>yum</package>, <indexterm id="idx_yum"> <primary>yum</primary>
        </indexterm> <package>blivet</package> <indexterm id="idx_blivet">
        <primary>blivet</primary> </indexterm> and
        <package>pyanaconda</package>.  <indexterm id="idx_pyanaconda">
        <primary>pyanaconda</primary> </indexterm>
        <package>pykickstart</package> is a package that parses and validates
        the kickstart file (if provided) and also provides a data structure that
        Anaconda uses to store values driving the installation. We will focus
        more on the data representation and life cycle in the following
        paragraph. <package>yum</package> is the core python package of the
        <command>yum</command> package manager. Anaconda uses it for operations
        with package repositories and for package
        installation. <package>blivet</package> is a new separate project that
        used to be an internal part of the <package>pyanaconda</package> package
        as <package>pyanaconda.storage</package>. As the old name suggests it is
        a package that operates on the disks, mount points and all related
        aspects of the installation destination preparation. Moreover it
        provides functions for boot loader installation and configuration. The
        most important package is <package>pyanaconda</package>. It glues all
        the other components together, contains all the UI code and many modules
        for things that are not handled anywhere else &mdash; e.g. keyboard,
        timezone, network and users configuration and also a number of utility
        and system oriented functions. There is also the <package> python-meh
        </package> <indexterm id="idx_meh"> <primary> python-meh </primary>
        </indexterm> package that contains an exception handler that gathers and
        stores additional information from the system in case of a crash and
        passes this data to the <package>libreport</package> <indexterm
        id="idx_libreport"> <primary> libreport </primary> </indexterm> library
        (which is a part of the <ulink url="https://fedorahosted.org/abrt/">ABRT
        project</ulink>). <indexterm id="idx_abrt"> <primary> ABRT </primary>
        </indexterm>
      </para>

      <!-- divide into subsections? -->
      <para>
        Life cycle of the data in the installation process is simple and
        straightforward. In the beginning if kickstart file is given to the
        installer, it is parsed and processed by the <package> pykickstart
        </package> module to become an in-memory treelike structure. If no
        kickstart file is given, and empty treelike structure is created. Items
        in that structure are then updated with the user's choices from the
        UI. Next step is the installation process which is driven by the values
        stored in that structure and finally all such values are written out as
        a new kickstart file that can be used to perform another installation
        with the same configuration. Elements of the structure are defined in
        the <package>pykickstart</package> package, but some of them are
        overridden by modified versions from the <package> pyanaconda.kickstart
        </package> module. The important fact and rule is that there is no other
        place to store configuration data and the installation process is data
        driven and as much transactional as possible. This neatly enforces some
        nice features:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            everything has to be supported in kickstart first (because in
            automated installation only the transaction happens),
          </para>
        </listitem>
        <listitem>
          <para>
            there is a single and obvious point where underlying machine starts
            to be modified (begging of the transaction) and
          </para>
        </listitem>
        <listitem>
          <para>
            everything set in the UI is reflected in the resulting kickstart file.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        What does it mean that the installation is data driven? It means that
        the installation (and configuration) logic lies in the methods of the
        items in the treelike structure. Every item is set up (the
        <methodname>setup</methodname> method) <indexterm id="idx_setup">
        <primary> setup </primary> </indexterm> to modify the runtime environment
        of the installation (if needed) and then executed (the
        <methodname>execute</methodname>) <indexterm id="idx_execute"> <primary>
        execute </primary> </indexterm> to do the changes on the newly installed
        system. We will look at these methods closer in <xref
        linkend="section_writing_addon"/>.
      </para>
    </section>

    <section id="section_hub_and_spoke">
      <title>Hub&amp;Spoke model</title>
      <para>
        One of the biggest changes introduced with the rewrite of the Anaconda
        installer was that the new UI (both graphical and textual) uses a
        hub&amp;spoke model <indexterm id="idx_hub_and_spoke"> <primary>
        hub&amp;spoke model </primary> </indexterm> instead of the wizard model
        that had been used before. The following diagram shows how hub&amp;spoke
        works regarding the possible transitions between screens (hubs and
        spokes).
      </para>

      <figure id="fig_hub_and_spoke">
        <title>Hub&amp;spoke model diagram</title>
        <mediaobject id="picture_hub_and_spoke">
          <imageobject>
            <imagedata fileref="images/hub_and_spoke.svg" format="SVG" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        The screens 2, 3, 5, 8, 10 and others are examples of so called
        <emphasis>normal spokes</emphasis>. Those are the screens reachable from
        hubs. The screens 1 and 14 are examples of a so called
        <emphasis>standalone spoke</emphasis> which is a type of screen that
        should be used only in case it has to be visited before (after) the
        following (previous) standalone spoke or hub.

        <footnote>
          <para>
            Screens mentioned in the rest of this section are screens from the
            graphical mode of the installation.
          </para>
        </footnote>

        The examples of such screens are the language and network configuration
        screens in the Anaconda installer that are implemented as standalone
        spokes because actions available on them have to and should,
        respectively, take place before all the other actions controlled from
        the user interface.
      </para>

      <para>
        The reason for the Hub&amp;Spoke model being used in the Anaconda
        installer's UI is that it has many advantages:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            users are not forced to go through the screens in some strictly
            defined order,
          </para>
        </listitem>
        <listitem>
          <para>
            users are not forced to visit every screen no matter if they
            understand what the options configured in it mean or not,
          </para>
        </listitem>
        <listitem>
          <para>
            it is good for the transactional mode where all desired values can
            be set while nothing is actually happening to the underlying machine
            until a special button is clicked,
          </para>
        </listitem>
        <listitem>
          <para>
            it provides way to show an overview of the configured values,
          </para>
        </listitem>
        <listitem>
          <para>
            it has a great support for extensibility, because additional spokes
            can be put on hubs without need to reorder anything and resolve some
            complex ordering dependencies and
          </para>
        </listitem>
        <listitem>
          <para>
            it can be used for both graphical and textual mode of the installer.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        As can be seen in <xref linkend="fig_hub_and_spoke"/> central points of
        the Hub&amp;Spoke model are hubs, so let's focus on hubs in the Anaconda
        installer for a while. Currently there are two of them:
      </para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>
            the Summary hub <indexterm id="idx_summary_hub"> <primary> Summary
            hub </primary> </indexterm> that shows a summary of configured
            options and
          </para>
        </listitem>
        <listitem>
          <para>
            the Progress hub <indexterm id="idx_progress_hub"> <primary>
            Progress hub </primary> </indexterm> that shows the progress of the
            installation process and also shows a summary of options that can be
            configured during the actual installation being done in the
            background thread.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        Every spoke has a few predefined properties that are reflected on the
        hub. There are: the <property> ready </property> property stating
        whether the spoke can be visited or not, the <property> completed
        </property> property marking the spoke as completed (all required values
        are set) or not, the <property> mandatory </property> property telling
        whether the spoke has to be completed before allowing user continue to
        the next hub or standalone spoke and the <property> status </property>
        property providing a short summary of the values set in the
        spoke. <indexterm id="idx_spoke_properties"> <primary> spokes'
        properties </primary>
        </indexterm> To make the layout of the UI clearer, spokes reachable from
        these two hubs are grouped together to so called <emphasis> categories
        </emphasis>. <indexterm id="idx_category"> <primary> category </primary>
        </indexterm> A good example of a category used in the Anaconda installer
        is the <emphasis> Localization </emphasis> <indexterm
        id="idx_local_cat"> <primary> Localization category </primary>
        </indexterm> category that groups together spokes for keyboard and
        timezone settings. So to sum it up there are hubs on the hubs there are
        categories and in the categories there are spokes. Every spoke contains
        UI controls that show and allow to modify values from one or more
        subtrees of the in-memory representation of the kickstart file. As we
        will see in <xref linkend="section_writing_addon"/> the same applies to
        addons.
      </para>
    </section>

    <section id="section_threads_and_communication">
      <title>Threads and communication</title>
      <para>
        Some of the actions that need to be run during the installation process
        take a long time to be finished (e.g. scanning disks for existing
        partitions, downloading package repository metadata, etc). And since
        basic principle of the GUI programming is that the user interface should
        be as responsive as possible and since the goal is to allow user
        configure other settings while some are blocked by the long lasting
        actions, the Anaconda installer has to run such actions in separate
        threads. However, the Gtk toolkit doesn't support changing its elements
        from multiple threads. The Gtk main event loop is running in the main
        thread of the Anaconda installer process and every code doing some GUI
        involving actions has to make sure that these actions are run in the
        main thread as well. The only supported way to do that is by using
        <methodname>GLib.idle_add</methodname> method which is not much
        comfortable. To facilitate this issue there are some helper functions
        and decorators <!--add reference--> defined in the <package>
        pyanaconda.ui.gui.utils </package> module. The most useful ones are
        <emphasis> @gtk_thread_wait </emphasis> and <emphasis>
        @gtk_thread_nowait </emphasis> decorators that change the decorated
        function or method in a way that when it is called it is automatically
        queued to Gtk's main loop, run in the main thread and then the return
        value is returned to the caller or dropped, respectively. Problem with
        these decorators is that a programmer has to make sure decorated
        functions are not called from the main thread as it would cause a
        deadlock. So as always using threads complicates the code, debugging and
        may lead to a whole set of additional problems if done in a way not
        careful enough.
      </para>

      <para>
        As it has been already mentioned one of the goals of using multiple
        threads is to allow user configure something else while some parts of
        the GUI wait for some actions to finish. The example of such case is
        package repository metadata download which can take a while and without
        it being finished the Source <indexterm id="idx_source_spoke"> <primary>
        Source spoke </primary> </indexterm> and Software <indexterm
        id="idx_softw_spoke"> <primary> Software spoke </primary> </indexterm>
        spokes cannot be visited as they cannot display valid data. But in the
        same time there is no reason why e.g. the Datetime spoke <indexterm
        id="idx_datetime_spoke"> <primary> Datetime spoke </primary>
        </indexterm> should be blocked. Now let's take a look from the blocked
        spoke's perspective. It waits for some background thread to finish. But
        once this thread is finished how should the spoke announce it is ready
        and should not be blocked anymore? The hub that provides an access to
        the spoke has no relation with the thread the spoke has been waiting for
        and thus can't tell whether the spoke is yet ready or not. For such
        cases there is a message queue called <emphasis>hubQ</emphasis>
        <indexterm id="idx_hubq"> <primary> hubQ </primary> </indexterm> that is
        being periodically checked in the main event loop. Once the thread the
        spoke has been waiting for is finished the spoke sends a message
        <footnote>
          <para>
            internally it means that it puts a message to the queue
          </para>
        </footnote>
        that announces the spoke should no longer be blocked. The same applies to
        the situation when the spoke needs to refresh its status or completion
        flag. In case of the Progress hub there is the <emphasis> progressQ
        </emphasis> <indexterm id="idx_progressq"> <primary>progressQ</primary>
        </indexterm> which serves as a medium to transfer installation progress
        updates. These mechanisms are needed also for the text mode where the
        situation is much more complicated, because there is no main loop in the
        text mode and for vast majority of time it is waiting for an input from
        keyboard. However there is (a bit experimental) implementation of
        asynchronous messages handling in TUI and the goal is to make, from
        spoke's perspective, everything very similar to the graphical user
        interface.
      </para>
    </section>

    <section id="section_addon_structure">
      <title>Addon structure</title>
      <para>
        Now that we know bits of how the Anaconda installer looks like and works
        internally, we can finally focus on the main topic of this guide,
        i.e. writing an addon for it. Let's take a top-down approach and start
        with the high-level aspects diving deeper and deeper. The only supported
        programming language for an Anaconda addon is Python with addon being a
        Python package. Thus it shouldn't be a surprise that an addon is
        actually a directory with an <filename>__init__.py</filename> and other
        source files and directories (subpackages) in it. And since one package
        name can be imported in Python only once, the top-level directory of an
        addon needs to have a unique name. The naming convention suggested for
        addons is to prefix the addon name with a reversed domain name as (it is
        common with e.g. D-Bus service names or Java packages) but using dashes
        instead of dots to separate subdomains so that the directory name is a
        valid identifier for a Python package. For example
        <filename class="directory">org_fedora_hello_world</filename> which is
        used by <ulink
        url="http://www.fi.muni.cz/~xpodzim/git/hello-world-anaconda-addon.git">
        the &HWADDON;</ulink> from <xref
        linkend="section_writing_addon"/>. <indexterm id="idx_hello_world">
        <primary> &HWADDON; </primary> </indexterm> As it has been
        mentioned in <xref linkend="section_introduction"/> everything should be
        supported in the kickstart first, then GUI and TUI pieces can come
        covering some (or all) configuration options from the kickstart part. As
        these three parts are more or less independent the Anaconda's addon API
        defines that they should be separate subpackages of the top-level addon
        package (i.e. subdirectories of the top-level directory) with the
        following names: <package>ks</package>, <package>gui</package> and
        <package>tui</package>, with the <package>ks</package> being the only
        compulsory one. The <package>gui</package> and <package>tui</package>
        packages should then contain <package> spokes </package> subpackages.
        <footnote>
          <para>
            The <package> gui </package> package may also contain a <package>
            categories </package> subpackage if the addon needs to define a new
            category, but this is not recommended.
          </para>
        </footnote>
        All these packages have to contain at least one module with an arbitrary
        name defining classes inherited from one or more API defined classes. We
        will get to those classes in <xref linkend="section_writing_addon"/>.
        <important>
          <para>
            Do not forget to create all the <filename>__init__.py</filename>
            files so that directories really are valid Python packages.
          </para>
        </important>
      </para>
    </section>

    <section id="section_writing_addon">
      <title>Writing an Anaconda addon</title>
      <para>
        We know how the addon's tree-like structure should look like, but
        obviously the actual work needs to be done in the leafs, the addon's
        modules. Instead of a lot of words describing how such modules should
        look like and what they should contain, let's create a simple addon step
        by step as a practical example. To make it obvious it is just a simple
        example, we will call it <emphasis>&HWADDON;</emphasis>.<indexterm
        id="idx_hello_world_addon"> <primary> &HWADDON; </primary> </indexterm>
        To get an overall view on the addon and the code it is recommended to
        clone the <ulink
        url="http://www.fi.muni.cz/~xpodzim/git/?p=hello-world-anaconda-addon.git">
        &HWADDON;'s git repository</ulink> or if it is not possible, at least
        use the web interface to open the source files. The same applies to the
        <ulink url="http://git.fedorahosted.org/git/anaconda.git">Anaconda's git
        repository</ulink> as the installer's sources will be referred many
        times in the following text.<indexterm id="idx_anaconda_git"> <primary>
        Anaconda git </primary> </indexterm>
      </para>

      <section id="section_kickstart_support">
        <title>Kickstart support</title>
      <para>
        First we need the directories as described in the <xref
        linkend="section_addon_structure"/> &mdash; the top-level directory
        giving the addon its name (in this case <filename
        class="directory">org_fedora_hello_world</filename>) and the directories
        for separate parts providing code for kickstart, GUI and TUI support. As
        it was already mentioned many times (intentionally) kickstart support is
        the most important one so let's start with that part. Its subpackage
        name is expected to be <package>ks</package> and we will thus need a
        directory named <filename class="directory">ks</filename> under the
        addon's top-level directory <filename
        class="directory">org_fedora_hello_world</filename>. In that directory
        there has to be the <filename>__init__.py</filename> file and at least
        one Python module with arbitrary name. Let's use
        <filename>hello_world.py</filename> which conforms to<ulink
        url="http://www.python.org/dev/peps/pep-0008/#package-and-module-names">
        Python's conventions for module names</ulink>. That brings us to the
        coding style questions that should be answer before we start with any
        actual code. The general rule is to follow Python's <ulink
        url="http://www.python.org/dev/peps/pep-0008/">PEP 8</ulink> and <ulink
        url="http://www.python.org/dev/peps/pep-0257/">PEP 257</ulink>
        (docstring conventions). There is no consensus on the format of the
        actual content of docstrings in the Anaconda installer. Anything that is
        well human-readable is okay only if the addon is supposed to have a
        documentation generated automatically, docstrings should, of course,
        follow the rules of the toolkit used to generate the documentation. But
        let's get back to the module with code providing &HWADDON;'s
        support for kickstart. The reason why it can have an arbitrary name is
        that the Anaconda installer looks in all files in the particular
        directory and collects classes that are inherited from a particular
        class defined by the API. The same rules apply to all of the <filename
        class="directory">ks</filename>, <filename
        class="directory">gui/spokes</filename> and <filename
        class="directory">tui/spokes</filename> directories containing
        modules. For the kickstart part of the addon the key class is the
        <classname>AddonData</classname> class defined in the
        <package>pyanaconda.addons</package> module that represents an object
        for parsing and storing data from the kickstart file. The part of a
        kickstart file containing data for an addon has the following format:

        <programlisting>%addon ADDON_NAME
first line
second line
...
%end</programlisting>

        Such sequence of lines is called <emphasis>a section</emphasis>. The
        percent sign followed by the keyword <emphasis>addon</emphasis> marks
        the beginning of addon section while <emphasis>%end</emphasis> marks its
        end. In place of the string <emphasis>ADDON_NAME</emphasis> there should
        be a name of a real addon (like
        <emphasis>org_fedora_hello_world</emphasis> in our case). The content
        between the two lines starting with the percent sign is passed to an
        instance of the addon's class inherited from the
        <classname>AddonData</classname> class. To make the code as simple as
        possible, the &HWADDON; will just squash the lines passed in a
        kickstart file to a single line separating the original lines with a
        space. We know that our addon needs a class inherited from the
        <classname>AddonData</classname> with a method handling lines from a
        kickstart <emphasis>%addon</emphasis> section. A quick look into the
        <filename>pyanaconda/addons.py</filename> file tells that the name of
        such method is <methodname>handle_line</methodname> and it takes the
        line as the only argument. Let's have a look at the code implementing
        what we have covered so far.
      </para>

      <programlisting>from pyanaconda.addons import AddonData

# export HelloWorldData class to prevent Anaconda's collect method from taking
# AddonData class instead of the HelloWorldData class
# @see: pyanaconda.kickstart.AnacondaKSHandler.__init__
__all__ = ["HelloWorldData"]

HELLO_FILE_PATH = "/root/hello_world_addon_output.txt"

class HelloWorldData(AddonData):
    """
    Class parsing and storing data for the Hello world addon.

    @see: pyanaconda.addons.AddonData

    """

    def __init__(self, name):
        """
        @param name: name of the addon
        @type name: str

        """

        AddonData.__init__(self, name)
        self.text = ""

    def handle_line(self, line):
        """
        The handle_line method that is called with every line from this addon's
        %addon section of the kickstart file.

        @param line: a single line from the %addon section
        @type line: str

        """

        # simple example, we just append lines to the text attribute
        if self.text is "":
            self.text = line.strip()
        else:
            self.text += " " + line.strip()</programlisting>
      <para>
        First few lines of the code describe what could be summed up as the
        following rule:

        <important>
          <para>
            Use <varname>__all__</varname> variables in modules as it is needed
            for Anaconda's method for collecting classes to work properly.
          </para>
        </important>

        Then there is a definition of the <classname>HelloWorldData</classname>
        class inherited from the <classname>AddonData</classname> class with its
        <methodname>__init__</methodname> method calling the parent's
        <methodname>__init__</methodname> method and initializing the attribute
        <property>self.text</property> to an empty string. This attribute is
        populated in the <methodname>handle_line</methodname> method which just
        strips the lines (removes white space characters at the beginning and the
        end) and appends them to it.
      </para>

      <para>
        So far our code covers the first phase of the data life cycle in the
        installation process where data from the kickstart file has to be
        read. The second phase of the life cycle is updating data with values
        from the UI which will be covered in the UI code. Then data is used to
        drive the actual installation process. This is done by two methods with
        predefined names -- <methodname>setup</methodname> and
        <methodname>execute</methodname>. The former one is called before the
        installation transaction starts and should do all changes of the runtime
        environment an addons needs to do. The later one is called at the end of
        the transaction and should do all changes to the newly installed
        (target) system an addon is supposed to do. Again, to make the code as
        simple as possible, these two methods will be minimalistic. We will need
        to prepend few imports and a constant definition to the begining of the
        source file:
      </para>

      <programlisting>import os.path

from pyanaconda.addons import AddonData
from pyanaconda.constants import ROOT_PATH

HELLO_FILE_PATH = "/root/hello_world_addon_output.txt"</programlisting>

      <para>
        And this is how the two methods will look:
      </para>

      <programlisting>    def setup(self, storage, ksdata, instclass):
        """
        The setup method that should make changes to the runtime environment
        according to the data stored in this object.

        @param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        @type storage: blivet.Blivet instance
        @param ksdata: data parsed from the kickstart file and set in the
                       installation process
        @type ksdata: pykickstart.base.BaseHandler instance
        @param instclass: distribution-specific information
        @type instclass: pyanaconda.installclass.BaseInstallClass

        """

        # no actions needed in this addon
        pass

    def execute(self, storage, ksdata, instclass, users):
        """
        The execute method that should make changes to the installed system. It
        is called only once in the post-install setup phase.

        @see: setup
        @param users: information about created users
        @type users: pyanaconda.users.Users instance

        """

        hello_file_path = os.path.normpath(ROOT_PATH + HELLO_FILE_PATH)
        with open(hello_file_path, "w") as fobj:
            fobj.write("%s\n" % self.text)
      </programlisting>

      <para>
        It should be easy to find out that the <methodname>setup</methodname>
        method does nothing and the <methodname>execute</methodname> method just
        writes the stored text to a file created in the target system's root
        (<filename class="directory">/</filename>) directory. The most important
        information delivered by the code above is the number and meaning of the
        arguments passed to those two methods as described in the docstrings.
      </para>

      <para>
        That brings us to the last phase of the data life cycle and also the
        last piece of the code needed in the module providing a kickstart
        support. At the end of the installation a new kickstart file with the
        values set in the original kickstart file or during the installation
        process is written out to the target system's <filename
        class="directory">/root</filename> directory. It is done by calling
        the <methodname>__str__</methodname> recursively on the tree-like
        structure storing the data which means that our class inherited from the
        <classname>AddonData</classname> class needs to define its own
        <methodname>__str__</methodname> method returning its stored data in the
        format that could be parsed again if the resulting kickstart file was
        used to install another similar system. It should be obvious how the
        <methodname>__str__</methodname> method should look like in our case:
      </para>

      <programlisting>    def __str__(self):
        """
        What should end up between %addon and %end lines in the resulting
        kickstart file, i.e. string representation of the stored data.

        """

        return self.text</programlisting>

      <para>
        By adding this method method we have everything that is needed for a
        kickstart support done and at the same time we have everything that an
        addon needs to implement to become a valid addon. Thus we could finish
        here and start enjoying the warm feeling of writing a new piece of the
        OS installer. And, believe it or not, we only needed 36 lines of code (not
        counting the docstrings and comments) to do that. But try to explain
        how great this is to a majority of people who don't like writing
        kickstart files and instead prefer clicking on buttons, filling in text
        entries and so on. To make our code reachable for such people we need to
        create a user interface for it.
      </para>
      </section>

      <section id="section_gui_support">
        <title>Graphical user interface</title>
      <para>
        Since the textual interface uses a custom toolkit developed for the
        Anaconda installer, let's start with the Graphical user interface using
        standard Gtk toolkit that should be more familiar to developers. Again,
        first we need a subdirectory (subpackage) in the addon's top-level
        directory (package). The one for the GUI code must be named <filename
        class="directory">gui</filename> and since there are more types of
        objects it can provide, it needs to have subdirectories itself. We will
        start with the most important and most common one &mdash; <filename
        class="directory">spokes</filename>. As it was described in the <xref
        linkend="section_kickstart_support"/> every part of the addon has to
        contain at least one module with a definition of a class inherited from
        a particular class defined by the API. In case of the kickstart support
        this class was the <classname>AddonData</classname> class in case of the
        GUI support there are multiple such classes. But the only recommended
        one for an addon is the <classname>NormalSpoke</classname> class defined
        in the <package>pyanaconda.ui.gui.spokes</package> package. As its name
        suggests it is a class for the <emphasis>normal spoke</emphasis> screen
        described in the <xref linkend="section_hub_and_spoke"/>. To implement a
        new class inherited from the <classname>NormalSpoke</classname> class we
        need to define the folowing class attributes required by the API:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            <varname>builderObjects</varname> that should list all top-level
            objects from the spoke's <filename>.glade</filename> file that
            should be, with their children objects (recursively), exposed to the
            spoke or should be an empty list if everything should be exposed to
            the spoke (not recommended),
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>mainWidgetName</varname> containing the id of the main
            window widget
            <footnote>
              <para>
                an instance of the SpokeWindow widget which is a custom widget
                created for the Anaconda installer
              </para>
            </footnote>
            as defined in the <filename>.glade</filename> file,
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>uiFile</varname> containing the name of the
            <filename>.glade</filename> file,
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>category</varname> containing the class of the category
            the spoke belongs to,
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>icon</varname> containing the identifier of the icon that
            will be used for the spoke on the hub and
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>title</varname> defining the title that will be used for
            the spoke on the hub.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        The code with all those definitions will then look like this:
      </para>
      <programlisting># will never be translated
_ = lambda x: x
N_ = lambda x: x

# the path to addons is in sys.path so we can import things from org_fedora_hello_world
from org_fedora_hello_world.gui.categories.hello_world import HelloWorldCategory
from pyanaconda.ui.gui.spokes import NormalSpoke

# export only the spoke, no helper functions, classes or constants
__all__ = ["HelloWorldSpoke"]

class HelloWorldSpoke(NormalSpoke):
    """
    Class for the Hello world spoke. This spoke will be in the Hello world
    category and thus on the Summary hub. It is a very simple example of
    a unit for the Anaconda's graphical user interface.

    @see: pyanaconda.ui.common.UIObject
    @see: pyanaconda.ui.common.Spoke
    @see: pyanaconda.ui.gui.GUIObject

    """

    ### class attributes defined by API ###

    # list all top-level objects from the .glade file that should be exposed
    # to the spoke or leave empty to extract everything
    builderObjects = ["helloWorldSpokeWindow", "buttonImage"]

    # the name of the main window widget
    mainWidgetName = "helloWorldSpokeWindow"

    # name of the .glade file in the same directory as this source
    uiFile = "hello_world.glade"

    # category this spoke belongs to
    category = HelloWorldCategory

    # spoke icon (will be displayed on the hub)
    # preferred are the -symbolic icons as these are used in Anaconda's spokes
    icon = "face-cool-symbolic"

    # title of the spoke (will be displayed on the hub)
    title = N_("_HELLO WORLD")</programlisting>

      <para>
        In the begining two common functions for translations are defined, but
        with the unusual definition for the <function>_</function>
        function. This is caused by the fact that our addon is not meant to have
        translations. Then we can again see the usage of the
        <varname>__all__</varname> variable to export only the spoke class
        <!--add reference to the warning?--> followed by the first lines of its
        definition including the definitions of attributes mentioned
        above. Their values are referencing the widgets defined in the
        <filename>org_fedora_hello_world/gui/spokes/hello.glade</filename> file
        included in the &HWADDON;'s sources (if you want to open the file, see
        the begining of the <xref linkend="section_deploying_and_testing"/> that
        lists the packages that are needed). Only two of the attributes deserve
        a further comment. The first one is the <varname>category</varname>
        attribute the value of which is the
        <classname>HelloWorldCategory</classname> class imported from the
        <package>org_fedora_hello_world.gui.categories</package> module. We will
        get to the <classname>HelloWorldCategory</classname> definition later,
        but for now note what was mentioned in the comment just before the
        import:

        <important>
          <para>
            The path to addons is in sys.path so things can be imported from the
            org_fedora_hello_world package.
          </para>
        </important>

        The second attribute that deserves a comment is the
        <varname>title</varname> attribute whose definition contains two
        underscores. The former one is part of the <function>N_</function>
        function name that marks the string for translation, but returns the
        non-translated version of the string (translation is done later). The
        latter one is part of the title itself and makes the spoke reachable
        from the hub with the Alt+H keyboard shortcut.
      </para>

      <para>
        What usually follows the header of the class definition and the class
        attributes definitions is the constructor that initializes an instance
        of the class. In case of the Anaconda installer's GUI objects there are
        two methods initializing a new instance &mdash; common Python's
        <methodname>__init__</methodname> method and the
        <methodname>initialize</methodname> method. The reason for two such
        functions is that the GUI objects may be created in memory at one time
        and fully initialized (which can take a longer time) at a different
        time. Thus the <methodname>__init__</methodname> method should only
        call the parent's <methodname>__init__</methodname> method and
        e.g. initialize non-GUI attributes. On the other hand the
        <methodname>initialize</methodname> method that is called when the
        installer's graphical user interface initializes should finish the full
        initialization of the spoke. This is how these two methods look in our
        case (note the number and description of the arguments passed to the
        <methodname>__init__</methodname> method):
      </para>

      <programlisting>    def __init__(self, data, storage, payload, instclass):
        """
        @see: pyanaconda.ui.common.Spoke.__init__
        @param data: data object passed to every spoke to load/store data
                     from/to it
        @type data: pykickstart.base.BaseHandler
        @param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        @type storage: blivet.Blivet
        @param payload: object storing packaging-related information
        @type payload: pyanaconda.packaging.Payload
        @param instclass: distribution-specific information
        @type instclass: pyanaconda.installclass.BaseInstallClass

        """

        NormalSpoke.__init__(self, data, storage, payload, instclass)

    def initialize(self):
        """
        The initialize method that is called after the instance is created.
        The difference between __init__ and this method is that this may take
        a long time and thus could be called in a separated thread.

        @see: pyanaconda.ui.common.UIObject.initialize

        """

        NormalSpoke.initialize(self)
        self._entry = self.builder.get_object("textEntry")</programlisting>

      <para>
        Both methods are very simple, but still there are few things deserving a
        comment. The most important one is the <varname>data</varname> parametr
        passed to the <methodname>__init__</methodname> method. It is the
        in-memory tree-like representation of the kickstart file where all the
        data is stored. In one of the ancestors'
        <methodname>__init__</methodname> methods it is stored in the
        <varname>self.data</varname> attribute so we can read and modify it in
        all other methods of the class. Since we have defined the
        <classname>HelloWorldData</classname> class in <xref
        linkend="section_kickstart_support"/> there is a subtree in
        <varname>self.data</varname> for our addon and its root (an instance of
        the <classname>HelloWorldData</classname>) is available as
        <varname>self.data.addons.org_fedora_hello_world</varname>. One of the
        other things an ancestor's <methodname>__init__</methodname> does is
        initializing an instance of the <classname>GtkBuilder</classname>
        with the spoke's <filename>.glade</filename> file and storing it as
        <varname>self.builder</varname>. This is used in the
        <methodname>initialize</methodname> method to get the
        <classname>GtkTextEntry</classname> used to show and modify the text
        from the kickstart file's %addon section.
      </para>

      <para>
        &HWADDON; example built step by step with comments and API
        description. Beware of Glade! Comments on the "advanced features"
        provided by Anaconda. What is needed for an installer addon to become an
        Initial Setup addon?
      </para>
      </section>

    </section>

    <section id="section_deploying_and_testing">
      <title>Deploying and testing an Anaconda addon</title>
      <para>
        Which packages are needed? How to deploy and test an Anaconda addon? On
        the running system vs. with the installation image. How should be an
        addon delivered? Packaging and basic structure for the .spec file.
      </para>
    </section>

    <section id="section_final_words">
      <title>Addons welcomed</title>
      <para>
        Where to find help with the development? Additional documentation and
        referential addon implementations? FAQ. Few words to encourage.
      </para>
    </section>

    <xi:include href="Revision_History.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
    <index />
</article>

