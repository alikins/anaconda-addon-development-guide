<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Anaconda_Addon_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<article status="draft">
    <xi:include href="Article_Info.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
    <section id="section_introduction">
      <title>Introduction</title>
      <para>
        Anaconda<indexterm id="idx_anaconda"> <primary>Anaconda</primary>
        </indexterm> is the operating system installer (OS) used in &FEDORA;,
        &RHEL; and their derivatives. At a closer look, it is a set of Python
        modules and scripts together with some additional files like Gtk widgets
        (written in C), systemd units and dracut libraries. Altogether they form
        a tool that allows users to set parameters of the resulting (target)
        system and then set such a system up on a machine. The final installation
        process has four major steps:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            installation destination preparation (usually disk partitioning)
          </para>
        </listitem>
        <listitem>
          <para>
            package and data installation
          </para>
        </listitem>
        <listitem>
          <para>
            boot loader installation and configuration
          </para>
        </listitem>
        <listitem>
          <para>
            configuration of the newly installed system
          </para>
        </listitem>
      </itemizedlist>

      <para>
        There are three ways the user can set parameters for the target
        system (and in some cases also for the installation process). The most
        commonly used is via the graphical user interface (GUI) <indexterm
        id="idx_gui"> <primary>GUI</primary> </indexterm> which should cover all
        common use cases and should be clear and easily understandable even for
        non-advanced users. Although Anaconda also supports installation over
        VNC <indexterm id="idx_vnc"> <primary>VNC</primary> </indexterm>, there
        are some corner cases where a textual interface is needed, such as
        installation over serial console on "exotic" pieces of hardware. For
        this reason, Anaconda also has a textual user interface (TUI)
        <indexterm id="idx_tui"> <primary>TUI</primary> </indexterm> that works
        the same way as a black-only line printer. This behavior was chosen as
        a result of various serial consoles not supporting cursor movement,
        colors and other "advanced" features. Text mode installation implements
        only the most important features of the graphical installation and
        usually needs to be combined with installer-specific command line
        arguments since it does not provide all of the options the GUI provides.
        The third and most advanced way to set installation parameters is by
        using a kickstart file. <indexterm id="idx_kickstart">
        <primary>kickstart</primary> </indexterm> This is a simple file with
        shell-like syntax which can contain data driving the installation
        process, which then runs automatically. If the kickstart file doesn't
        contain all data required, the installer asks the user about the missing
        pieces. More information about kickstart can be found at <ulink
        url="http://fedoraproject.org/wiki/Anaconda/Kickstart">the
        Anaconda/Kickstart wiki page</ulink>. Addons related kickstart
        specifications are covered in <xref linkend="section_addon_structure"/>.
        The important distinction to note is that, compared to the TUI, which is
        not a full-featured mode of installation, kickstart installation
        provides the highest number of configuration options. The golden rule is
        that everything has to be supported in kickstart first. Then the GUI and
        TUI pieces can follow, supporting subsets of configuration options
        provided in kickstart that allow the user interface (UI) to remain clear
        and succinct. Anaconda has to maintain a balance between simplicity and
        complexity which is difficult to achieve.
      </para>

      <para>
        It should be clear by now that there are many things which need to
        happen during the installation process. Many teams and individuals favor
        the idea of adding more options to the installer so the target system
        can be pre-configured before it is run for the first time. On one hand,
        the installation environment is quite specific, and commonly used tools
        utilized by Anaconda are not always ready to work in it. On the other
        hand, once a feature is supported via kickstart, multiple systems with
        the same configuration can be installed easily. However, the more code
        in the installer, the more bugs it contains. Moreover, the maintenance
        becomes increasingly difficult with additional functionality, which
        makes it difficult to follow changes in so many areas. For these
        reasons, it was decided when doing a major rewrite of the Anaconda
        installer, support for addons <indexterm id="idx_addon">
        <primary>addon</primary> </indexterm> must be added. This allows other
        teams and individuals to participate and contribute as experts in their
        particular areas of interest by developing and maintaining their own
        pieces of code. This guide is intended to serve as a tool for lowering
        the barrier to entry by providing an understanding of how the Anaconda
        installer works and looks like internally, as well as explaining how its
        functionality can be extended with an addon.
      </para>

      <para>
        Traditionally, the first boot of the newly installed system is also
        considered to be a part of the installation procedure--usually, some
        configuration of the system (e.g. user creation) is taking place at
        this point. For many years there has been a graphical tool called <ulink
        url="http://fedoraproject.org/wiki/FirstBoot">Firstboot</ulink>
        <indexterm id="idx_firstboot"><primary>Firstboot</primary></indexterm>,
        which has helped users configure some aspects of the newly installed
        system. The issue with Firstboot is that it is using Gtk2 and the pygtk
        module, which are both no longer being developed. Since the goal was to
        provide all existing options from Firstboot during the installation
        process, it was obvious that the rewritten Firstboot should be sharing
        code with the Anaconda installer.

        <footnote>
          <para>
            At the same time, it was obvious that the old Firstboot had to be
            kept working because of the third-party modules written for it.
          </para>
        </footnote>

        That is how a new tool called <ulink
        url="http://fedoraproject.org/wiki/Features/NewFirstboot"> Initial
        Setup</ulink> <indexterm id="idx_is"><primary>Initial Setup</primary>
        </indexterm> was born. It reuses a lot of code from the installer: it
        has the same model and design as anaconda, and it reads data produced by
        the installer to show which values are set during the installation
        process. Most noteworthy is that only a little is needed for an Anaconda
        addon to become an Initial Setup addon. This is explained in more detail
        in <xref linkend="section_writing_addon"/>.
      </para>

      <para>
        Some additional information about the Anaconda installer can be found at
        <ulink url="http://fedoraproject.org/wiki/Anaconda">the Anaconda wiki
        page</ulink>, and additional information about the rewrite can be found
        at <ulink url="https://fedoraproject.org/wiki/Anaconda/NewInstaller">the
        Anaconda/NewInstaller wiki page</ulink>.
      </para>
    </section>

    <section id="section_architecture">
      <title>Architecture</title>
      <para>
        As already noted, the Anaconda installer is a set of
        python modules and scripts. It also uses a number of external packages
        and libraries, some of which were originally created specifically for
        the installer. Major components of the toolset include the
        following packages: <package>pykickstart</package>, <indexterm
        id="idx_pykickstart"> <primary>pykickstart</primary> </indexterm>
        <package>yum</package>, <indexterm id="idx_yum"> <primary>yum</primary>
        </indexterm> <package>blivet</package> <indexterm id="idx_blivet">
        <primary>blivet</primary> </indexterm> and
        <package>pyanaconda</package>.  <indexterm id="idx_pyanaconda">
        <primary>pyanaconda</primary> </indexterm>
        <package>pykickstart</package> is a package that parses and validates
        a provided kickstart file and also provides a data structure that
        Anaconda uses to store values driving installation. We will focus
        more on the data representation and life cycle in the following
        paragraph. <package>yum</package> is the core python package of the
        <command>yum</command> package manager. Anaconda uses it to interface
        with package repositories and handle operations related to package
        management during installation.
        <package>blivet</package> is a relatively recent project which was split
        out from the <package>pyanaconda</package> package as
        <package>pyanaconda.storage</package>. As the old name suggests, blivet
        is a storage library which handles all activities related to disk
        management. Additionally, it provides functions for boot loader
        installation and configuration. The <package>pyanaconda</package>
        package acts as a glue for holding all of the components together; it
        contains all of the UI code and several modules for functionality unique
        to anaconda, such as keyboard and timezone selection, network
        configuration, and user creation, as well as a number of utilities and
        system-oriented functions.

        There is also the <package> python-meh
        </package> <indexterm id="idx_meh"> <primary> python-meh </primary>
        </indexterm> package which contains an exception handler that gathers and
        stores additional information from the system in case of a crash and
        passes this data to the <package>libreport</package> <indexterm
        id="idx_libreport"> <primary> libreport </primary> </indexterm> library,
        which is a part of the <ulink url="https://fedorahosted.org/abrt/">ABRT
        project</ulink>. <indexterm id="idx_abrt"> <primary> ABRT </primary>
        </indexterm>
      </para>

      <!-- divide into subsections? -->
      <para>
        The life cycle of the data in the installation process is simple and
        straightforward. If a kickstart file is provided, it is parsed and
        processed by the <package>pykickstart</package> module to behave as an
        in-memory, tree-like structure. If no kickstart file is given, an empty
        tree-like structure is created. Items in this structure are then updated
        with the user's choices as they are made within the UI. Next, the
        installation process begins, and it is driven by the values which are
        stored in the tree-like structure. At this point, the values are also
        written out as a kickstart file which can be used to perform another
        installation with the same configuration. Elements of the structure are
        defined in the <package>pykickstart</package> package, but some of them
        are overridden by modified versions from the
        <package>pyanaconda.kickstart</package> module. The important rule which
        governs this behavior is that there is nowhere to store configuration
        data, and the installation process is data-driven and relies on
        transactions as much as possible. This neatly enforces some nice
        features:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            everything has to be supported in kickstart first, because in an
            automated installation only the transaction happens
          </para>
        </listitem>
        <listitem>
          <para>
            there is a single and obvious point where the underlying machine starts
            to be modified -- this marks the beginning of the transaction
          </para>
        </listitem>
        <listitem>
          <para>
            everything configured in the UI is reflected in the resultant
            kickstart file
          </para>
        </listitem>
      </itemizedlist>
      <para>
        What does it mean that the installation is data-driven? The installation
        and configuration logic lies within the methods of the items in the
        tree-like structure. Every item is set up (the
        <methodname>setup</methodname> method) <indexterm id="idx_setup">
        <primary> setup </primary> </indexterm> to modify the runtime environment
        of the installation if needed, and then executed (the
        <methodname>execute</methodname>) <indexterm id="idx_execute"> <primary>
        execute </primary> </indexterm> to perform the changes on the newly
        installed system. We will look at these methods closer in <xref
        linkend="section_writing_addon"/>.
      </para>
    </section>

    <section id="section_hub_and_spoke">
      <title>Hub&amp;Spoke model</title>
      <para>
        One of the biggest changes introduced with the rewrite of the Anaconda
        installer was that the new UI (both graphical and textual) uses a
        hub&amp;spoke model <indexterm id="idx_hub_and_spoke"> <primary>
        hub&amp;spoke model </primary> </indexterm> instead of the wizard model
        that had been used before. The following diagram shows how hub&amp;spoke
        works regarding the possible transitions between screens (hubs and
        spokes).
      </para>

      <figure id="fig_hub_and_spoke">
        <title>Hub&amp;spoke model diagram</title>
        <mediaobject id="picture_hub_and_spoke">
          <imageobject>
            <imagedata fileref="images/hub_and_spoke.svg" format="SVG" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        The screens 2, 3, 5, 8, 10 and others are examples of so called
        <emphasis>normal spokes</emphasis>. Those are the screens reachable from
        hubs. The screens 1 and 14 are examples of a so called
        <emphasis>standalone spoke</emphasis> which is a type of screen that
        should be used only in case it has to be visited before (after) the
        following (previous) standalone spoke or hub.

        <footnote>
          <para>
            Screens mentioned in the rest of this section are screens from the
            graphical mode of the installation.
          </para>
        </footnote>

        The examples of such screens are the language and network configuration
        screens in the Anaconda installer that are implemented as standalone
        spokes because actions available on them have to and should,
        respectively, take place before all the other actions controlled from
        the user interface.
      </para>

      <para>
        The reason for the Hub&amp;Spoke model being used in the Anaconda
        installer's UI is that it has many advantages:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            users are not forced to go through the screens in some strictly
            defined order,
          </para>
        </listitem>
        <listitem>
          <para>
            users are not forced to visit every screen no matter if they
            understand what the options configured in it mean or not,
          </para>
        </listitem>
        <listitem>
          <para>
            it is good for the transactional mode where all desired values can
            be set while nothing is actually happening to the underlying machine
            until a special button is clicked,
          </para>
        </listitem>
        <listitem>
          <para>
            it provides way to show an overview of the configured values,
          </para>
        </listitem>
        <listitem>
          <para>
            it has a great support for extensibility, because additional spokes
            can be put on hubs without need to reorder anything and resolve some
            complex ordering dependencies and
          </para>
        </listitem>
        <listitem>
          <para>
            it can be used for both graphical and textual mode of the installer.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        As can be seen in <xref linkend="fig_hub_and_spoke"/> central points of
        the Hub&amp;Spoke model are hubs, so let's focus on hubs in the Anaconda
        installer for a while. Currently there are two of them:
      </para>

      <itemizedlist mark="bullet">
        <listitem>
          <para>
            the Summary hub <indexterm id="idx_summary_hub"> <primary> Summary
            hub </primary> </indexterm> that shows a summary of configured
            options and
          </para>
        </listitem>
        <listitem>
          <para>
            the Progress hub <indexterm id="idx_progress_hub"> <primary>
            Progress hub </primary> </indexterm> that shows the progress of the
            installation process and also shows a summary of options that can be
            configured during the actual installation being done in the
            background thread.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        Every spoke has a few predefined properties that are reflected on the
        hub. There are: the <property> ready </property> property stating
        whether the spoke can be visited or not, the <property> completed
        </property> property marking the spoke as completed (all required values
        are set) or not, the <property> mandatory </property> property telling
        whether the spoke has to be completed before allowing user continue to
        the next hub or standalone spoke and the <property> status </property>
        property providing a short summary of the values set in the
        spoke. <indexterm id="idx_spoke_properties"> <primary> spokes'
        properties </primary>
        </indexterm> To make the layout of the UI clearer, spokes reachable from
        these two hubs are grouped together to so called <emphasis> categories
        </emphasis>. <indexterm id="idx_category"> <primary> category </primary>
        </indexterm> A good example of a category used in the Anaconda installer
        is the <emphasis> Localization </emphasis> <indexterm
        id="idx_local_cat"> <primary> Localization category </primary>
        </indexterm> category that groups together spokes for keyboard and
        timezone settings. So to sum it up there are hubs on the hubs there are
        categories and in the categories there are spokes. Every spoke contains
        UI controls that show and allow to modify values from one or more
        subtrees of the in-memory representation of the kickstart file. As we
        will see in <xref linkend="section_writing_addon"/> the same applies to
        addons.
      </para>
    </section>

    <section id="section_threads_and_communication">
      <title>Threads and communication</title>
      <para>
        Some of the actions that need to be run during the installation process
        take a long time to be finished (e.g. scanning disks for existing
        partitions, downloading package repository metadata, etc). And since
        basic principle of the GUI programming is that the user interface should
        be as responsive as possible and since the goal is to allow user
        configure other settings while some are blocked by the long lasting
        actions, the Anaconda installer has to run such actions in separate
        threads. However, the Gtk toolkit doesn't support changing its elements
        from multiple threads. The Gtk main event loop is running in the main
        thread of the Anaconda installer process and every code doing some GUI
        involving actions has to make sure that these actions are run in the
        main thread as well. The only supported way to do that is by using
        <methodname>GLib.idle_add</methodname> method which is not much
        comfortable. To facilitate this issue there are some helper functions
        and decorators <!--add reference--> defined in the <package>
        pyanaconda.ui.gui.utils </package> module. The most useful ones are
        <emphasis> @gtk_action_wait </emphasis> and <emphasis>
        @gtk_action_nowait </emphasis> decorators that change the decorated
        function or method in a way that when it is called it is automatically
        queued to Gtk's main loop, run in the main thread and then the return
        value is returned to the caller or dropped, respectively.
      </para>

      <para>
        As it has been already mentioned one of the goals of using multiple
        threads is to allow user configure something else while some parts of
        the GUI wait for some actions to finish. The example of such case is
        package repository metadata download which can take a while and without
        it being finished the Source <indexterm id="idx_source_spoke"> <primary>
        Source spoke </primary> </indexterm> and Software <indexterm
        id="idx_softw_spoke"> <primary> Software spoke </primary> </indexterm>
        spokes cannot be visited as they cannot display valid data. But in the
        same time there is no reason why e.g. the Datetime spoke <indexterm
        id="idx_datetime_spoke"> <primary> Datetime spoke </primary>
        </indexterm> should be blocked. Now let's take a look from the blocked
        spoke's perspective. It waits for some background thread to finish. But
        once this thread is finished how should the spoke announce it is ready
        and should not be blocked anymore? The hub that provides an access to
        the spoke has no relation with the thread the spoke has been waiting for
        and thus can't tell whether the spoke is yet ready or not. For such
        cases there is a message queue called <emphasis>hubQ</emphasis>
        <indexterm id="idx_hubq"> <primary> hubQ </primary> </indexterm> that is
        being periodically checked in the main event loop. Once the thread the
        spoke has been waiting for is finished the spoke sends a message
        <footnote>
          <para>
            internally it means that it puts a message to the queue
          </para>
        </footnote>
        that announces the spoke should no longer be blocked. The same applies to
        the situation when the spoke needs to refresh its status or completion
        flag. In case of the Progress hub there is the <emphasis> progressQ
        </emphasis> <indexterm id="idx_progressq"> <primary>progressQ</primary>
        </indexterm> which serves as a medium to transfer installation progress
        updates. These mechanisms are needed also for the text mode where the
        situation is much more complicated, because there is no main loop in the
        text mode and for vast majority of time it is waiting for an input from
        keyboard. However there is (a bit experimental) implementation of
        asynchronous messages handling in TUI and the goal is to make, from
        spoke's perspective, everything very similar to the graphical user
        interface.
      </para>
    </section>

    <section id="section_addon_structure">
      <title>Addon structure</title>
      <para>
        Now that we know bits of how the Anaconda installer looks like and works
        internally, we can finally focus on the main topic of this guide,
        i.e. writing an addon for it. Let's take a top-down approach and start
        with the high-level aspects diving deeper and deeper. The only supported
        programming language for an Anaconda addon is Python with addon being a
        Python package. Thus it shouldn't be a surprise that an addon is
        actually a directory with an <filename>__init__.py</filename> and other
        source files and directories (subpackages) in it. And since one package
        name can be imported in Python only once, the top-level directory of an
        addon needs to have a unique name. The naming convention suggested for
        addons is to prefix the addon name with a reversed domain name as (it is
        common with e.g. D-Bus service names or Java packages) but using dashes
        instead of dots to separate subdomains so that the directory name is a
        valid identifier for a Python package. For example
        <filename class="directory">org_fedora_hello_world</filename> which is
        used by <ulink
        url="https://github.com/vpodzime/hello-world-anaconda-addon">
        the &HWADDON;</ulink> from <xref
        linkend="section_writing_addon"/>. <indexterm id="idx_hello_world">
        <primary> &HWADDON; </primary> </indexterm> As it has been
        mentioned in <xref linkend="section_introduction"/> everything should be
        supported in the kickstart first, then GUI and TUI pieces can come
        covering some (or all) configuration options from the kickstart part. As
        these three parts are more or less independent the Anaconda's addon API
        defines that they should be separate subpackages of the top-level addon
        package (i.e. subdirectories of the top-level directory) with the
        following names: <package>ks</package>, <package>gui</package> and
        <package>tui</package>, with the <package>ks</package> being the only
        compulsory one. The <package>gui</package> and <package>tui</package>
        packages should then contain <package> spokes </package> subpackages.
        <footnote>
          <para>
            The <package> gui </package> package may also contain a <package>
            categories </package> subpackage if the addon needs to define a new
            category, but this is not recommended.
          </para>
        </footnote>
        All these packages have to contain at least one module with an arbitrary
        name defining classes inherited from one or more API defined classes. We
        will get to those classes in <xref linkend="section_writing_addon"/>.
        <important>
          <para>
            Do not forget to create all the <filename>__init__.py</filename>
            files so that directories really are valid Python packages.
          </para>
        </important>
      </para>
    </section>

    <section id="section_writing_addon">
      <title>Writing an Anaconda addon</title>
      <para>
        We know how the addon's tree-like structure should look like, but
        obviously the actual work needs to be done in the leafs, the addon's
        modules. Instead of a lot of words describing how such modules should
        look like and what they should contain, let's create a simple addon step
        by step as a practical example. To make it obvious it is just a simple
        example, we will call it <emphasis>&HWADDON;</emphasis>.<indexterm
        id="idx_hello_world_addon"> <primary> &HWADDON; </primary> </indexterm>
        To get an overall view on the addon and the code it is recommended to
        clone the <ulink
        url="https://github.com/vpodzime/hello-world-anaconda-addon.git">
        &HWADDON;'s git repository</ulink> or if it is not possible, at least
        use the web interface to open the source files. The same applies to the
        <ulink url="http://git.fedorahosted.org/git/anaconda.git">Anaconda's git
        repository</ulink> as the installer's sources will be referred many
        times in the following text.<indexterm id="idx_anaconda_git"> <primary>
        Anaconda git </primary> </indexterm>
      </para>

      <section id="section_kickstart_support">
        <title>Kickstart support</title>
      <para>
        First we need the directories as described in the <xref
        linkend="section_addon_structure"/> &mdash; the top-level directory
        giving the addon its name (in this case <filename
        class="directory">org_fedora_hello_world</filename>) and the directories
        for separate parts providing code for kickstart, GUI and TUI support. As
        it was already mentioned many times (intentionally) kickstart support is
        the most important one so let's start with that part. Its subpackage
        name is expected to be <package>ks</package> and we will thus need a
        directory named <filename class="directory">ks</filename> under the
        addon's top-level directory <filename
        class="directory">org_fedora_hello_world</filename>. In that directory
        there has to be the <filename>__init__.py</filename> file and at least
        one Python module with arbitrary name. Let's use
        <filename>hello_world.py</filename> which conforms to<ulink
        url="http://www.python.org/dev/peps/pep-0008/#package-and-module-names">
        Python's conventions for module names</ulink>. That brings us to the
        coding style questions that should be answer before we start with any
        actual code. The general rule is to follow Python's <ulink
        url="http://www.python.org/dev/peps/pep-0008/">PEP 8</ulink> and <ulink
        url="http://www.python.org/dev/peps/pep-0257/">PEP 257</ulink>
        (docstring conventions). There is no consensus on the format of the
        actual content of docstrings in the Anaconda installer. Anything that is
        well human-readable is okay only if the addon is supposed to have a
        documentation generated automatically, docstrings should, of course,
        follow the rules of the toolkit used to generate the documentation. But
        let's get back to the module with code providing &HWADDON;'s
        support for kickstart. The reason why it can have an arbitrary name is
        that the Anaconda installer looks in all files in the particular
        directory and collects classes that are inherited from a particular
        class defined by the API. The same rules apply to all of the <filename
        class="directory">ks</filename>, <filename
        class="directory">gui/spokes</filename> and <filename
        class="directory">tui/spokes</filename> directories containing
        modules. For the kickstart part of the addon the key class is the
        <classname>AddonData</classname> class defined in the
        <package>pyanaconda.addons</package> module that represents an object
        for parsing and storing data from the kickstart file. The part of a
        kickstart file containing data for an addon has the following format:

        <programlisting>%addon ADDON_NAME [arguments]
first line
second line
...
%end</programlisting>

        Such sequence of lines is called <emphasis>a section</emphasis>. The
        percent sign followed by the keyword <emphasis>addon</emphasis> marks
        the beginning of addon section while <emphasis>%end</emphasis> marks its
        end. In place of the string <emphasis>ADDON_NAME</emphasis> there should
        be a name of a real addon (like
        <emphasis>org_fedora_hello_world</emphasis> in our case). Any additional
        <emphasis>arguments</emphasis> on the addon line will be passed as a
        list to an instance of the addon's class inherited from the
        <classname>AddonData</classname> class. The content between the two
        lines starting with the percent sign is passed to the instance of the
        addon's class one line at a time.  To make the code as simple as
        possible, the &HWADDON; will just squash the lines passed in a
        kickstart file to a single line separating the original lines with a
        space. We know that our addon needs a class inherited from the
        <classname>AddonData</classname> with a method handling the
        <emphasis>%addon</emphasis> argument list and with a method handling
        lines inside a kickstart <emphasis>%addon</emphasis> section. A quick
        look into the <filename>pyanaconda/addons.py</filename> shows these
        two methods: <methodname>handle_header</methodname> takes a list of
        arguments and the current line numbers (for error reporting), and
        <methodname>handle_line</methodname> takes a single line of content.
        Let's have a look at the code implementing what we have covered so far.
      </para>

      <programlisting>from pyanaconda.addons import AddonData
from pykickstart.options import KSOptionParser

# export HelloWorldData class to prevent Anaconda's collect method from taking
# AddonData class instead of the HelloWorldData class
# :see: pyanaconda.kickstart.AnacondaKSHandler.__init__
__all__ = ["HelloWorldData"]

HELLO_FILE_PATH = "/root/hello_world_addon_output.txt"

class HelloWorldData(AddonData):
    """
    Class parsing and storing data for the Hello world addon.

    :see: pyanaconda.addons.AddonData

    """

    def __init__(self, name):
        """
        :param name: name of the addon
        :type name: str

        """

        AddonData.__init__(self, name)
        self.text = ""
        self.reverse = False

    def handle_header(self, lineno, args):
        """
        The handle_header method is called to parse additional arguments in the
        %addon section line.

        :param lineno: the current linenumber in the kickstart file
        :type lineno: int
        :param args: any additional arguments after %addon &lt;name&gt;
        :type args: list
        """

        op = KSOptionParser()
        op.add_option("--reverse", action="store_true", default=False,
                dest="reverse", help="Reverse the display of the addon text")
        (opts, extra) = op.parse_args(args=args, lineno=lineno)

        # Reject any additional arguments.
        if extra:
            msg = "Unhandled arguments on %%addon line for %s" % self.name
            if lineno != None:
                raise KickstartParseError(formatErrorMsg(lineno, msg=msg))
            else:
                raise KickstartParseError(msg)

        # Store the result of the option parsing
        self.reverse = opts.reverse

    def handle_line(self, line):
        """
        The handle_line method that is called with every line from this addon's
        %addon section of the kickstart file.

        :param line: a single line from the %addon section
        :type line: str

        """

        # simple example, we just append lines to the text attribute
        if self.text is "":
            self.text = line.strip()
        else:
            self.text += " " + line.strip()</programlisting>
      <para>
        First few lines of the code describe what could be summed up as the
        following rule:

        <important>
          <para>
            Use <varname>__all__</varname> variables in modules as it is needed
            for Anaconda's method for collecting classes to work properly.
          </para>
        </important>

        Then there is a definition of the <classname>HelloWorldData</classname>
        class inherited from the <classname>AddonData</classname> class with its
        <methodname>__init__</methodname> method calling the parent's
        <methodname>__init__</methodname> method and initializing the attributes
        <property>self.text</property> to an empty string and
        <property>self.reverse</property> to False.
        <property>self.reverse</property> is populated in the
        <methodname>handle_header</methodname> method, and
        <property>self.text</property> is populated in the
        <methodname>handle_line</methodname> method.
        <methodname>handle_header</methodname> uses an instance of the
        <classname>KSOptionParser</classname> class provided by pykickstart to
        parse the additional arguments on the <emphasis>%addon</emphasis> line,
        and <methodname>handle_line</methodname> strips the content lines
        (removes white space characters at the beginning and the end) and
        appends them to <property>self.text</property>.
      </para>

      <para>
        So far our code covers the first phase of the data life cycle in the
        installation process where data from the kickstart file has to be
        read. The second phase of the life cycle is updating data with values
        from the UI which will be covered in the UI code. Then data is used to
        drive the actual installation process. This is done by two methods with
        predefined names &mdash; <methodname>setup</methodname> and
        <methodname>execute</methodname>. The former one is called before the
        installation transaction starts and should do all changes of the runtime
        environment an addons needs to do. The later one is called at the end of
        the transaction and should do all changes to the newly installed
        (target) system an addon is supposed to do. Again, to make the code as
        simple as possible, these two methods will be minimalistic. We will need
        to prepend few imports and a constant definition to the begining of the
        source file:
      </para>

      <programlisting>import os.path

from pyanaconda.addons import AddonData
from pyanaconda.constants import ROOT_PATH

HELLO_FILE_PATH = "/root/hello_world_addon_output.txt"</programlisting>

      <para>
        And this is how the two methods will look:
      </para>

      <programlisting>    def setup(self, storage, ksdata, instclass):
        """
        The setup method that should make changes to the runtime environment
        according to the data stored in this object.

        :param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        :type storage: blivet.Blivet instance
        :param ksdata: data parsed from the kickstart file and set in the
                       installation process
        :type ksdata: pykickstart.base.BaseHandler instance
        :param instclass: distribution-specific information
        :type instclass: pyanaconda.installclass.BaseInstallClass

        """

        # no actions needed in this addon
        pass

    def execute(self, storage, ksdata, instclass, users):
        """
        The execute method that should make changes to the installed system. It
        is called only once in the post-install setup phase.

        :see: setup
        :param users: information about created users
        :type users: pyanaconda.users.Users instance

        """

        hello_file_path = os.path.normpath(ROOT_PATH + HELLO_FILE_PATH)
        with open(hello_file_path, "w") as fobj:
            fobj.write("%s\n" % self.text)
      </programlisting>

      <para>
        It should be easy to find out that the <methodname>setup</methodname>
        method does nothing and the <methodname>execute</methodname> method just
        writes the stored text to a file created in the target system's root
        (<filename class="directory">/</filename>) directory. The most important
        information delivered by the code above is the number and meaning of the
        arguments passed to those two methods as described in the docstrings.
      </para>

      <para>
        That brings us to the last phase of the data life cycle and also the
        last piece of the code needed in the module providing a kickstart
        support. At the end of the installation a new kickstart file with the
        values set in the original kickstart file or during the installation
        process is written out to the target system's <filename
        class="directory">/root</filename> directory. It is done by calling
        the <methodname>__str__</methodname> recursively on the tree-like
        structure storing the data which means that our class inherited from the
        <classname>AddonData</classname> class needs to define its own
        <methodname>__str__</methodname> method returning its stored data in the
        format that could be parsed again if the resulting kickstart file was
        used to install another similar system. It should be obvious how the
        <methodname>__str__</methodname> method should look like in our case:
      </para>

      <programlisting>    def __str__(self):
        """
        What should end up in the resulting kickstart file, i.e. the %addon
        section containing string representation of the stored data.

        """

        addon_str = "%%addon %s" % self.name

        if self.reverse:
            addon_str += " --reverse"

        addon_str += "\n%s\n%%end\n" % self.text
        return addon_str</programlisting>

      <para>
        By adding this method method we have everything that is needed for a
        kickstart support done and at the same time we have everything that an
        addon needs to implement to become a valid addon. Thus we could finish
        here and start enjoying the warm feeling of writing a new piece of the
        OS installer. And, believe it or not, we only needed 36 lines of code (not
        counting the docstrings and comments) to do that. But try to explain
        how great this is to a majority of people who don't like writing
        kickstart files and instead prefer clicking on buttons, filling in text
        entries and so on. To make our code reachable for such people we need to
        create a user interface for it.
      </para>
      </section>

      <section id="section_gui_support">
        <title>Graphical user interface</title>
        <section id="basic_features">
          <title>Basic features</title>
      <para>
        Since the textual interface uses a custom toolkit developed for the
        Anaconda installer, let's start with the Graphical user interface using
        standard Gtk toolkit that should be more familiar to developers. Again,
        first we need a subdirectory (subpackage) in the addon's top-level
        directory (package). The one for the GUI code must be named <filename
        class="directory">gui</filename> and since there are more types of
        objects it can provide, it needs to have subdirectories itself. We will
        start with the most important and most common one &mdash; <filename
        class="directory">spokes</filename>. As it was described in the <xref
        linkend="section_kickstart_support"/> every part of the addon has to
        contain at least one module with a definition of a class inherited from
        a particular class defined by the API. In case of the kickstart support
        this class was the <classname>AddonData</classname> class in case of the
        GUI support there are multiple such classes. But the only recommended
        one for an addon is the <classname>NormalSpoke</classname> class defined
        in the <package>pyanaconda.ui.gui.spokes</package> package. As its name
        suggests it is a class for the <emphasis>normal spoke</emphasis> screen
        described in the <xref linkend="section_hub_and_spoke"/>. To implement a
        new class inherited from the <classname>NormalSpoke</classname> class we
        need to define the folowing class attributes required by the API:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            <varname>builderObjects</varname> that should list all top-level
            objects from the spoke's <filename>.glade</filename> file that
            should be, with their children objects (recursively), exposed to the
            spoke or should be an empty list if everything should be exposed to
            the spoke (not recommended),
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>mainWidgetName</varname> containing the id of the main
            window widget
            <footnote>
              <para>
                an instance of the SpokeWindow widget which is a custom widget
                created for the Anaconda installer
              </para>
            </footnote>
            as defined in the <filename>.glade</filename> file,
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>uiFile</varname> containing the name of the
            <filename>.glade</filename> file,
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>category</varname> containing the class of the category
            the spoke belongs to,
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>icon</varname> containing the identifier of the icon that
            will be used for the spoke on the hub and
          </para>
        </listitem>
        <listitem>
          <para>
            <varname>title</varname> defining the title that will be used for
            the spoke on the hub.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        The code with all those definitions will then look like this:
      </para>
      <programlisting># will never be translated
_ = lambda x: x
N_ = lambda x: x

# the path to addons is in sys.path so we can import things from org_fedora_hello_world
from org_fedora_hello_world.gui.categories.hello_world import HelloWorldCategory
from pyanaconda.ui.gui.spokes import NormalSpoke

# export only the spoke, no helper functions, classes or constants
__all__ = ["HelloWorldSpoke"]

class HelloWorldSpoke(NormalSpoke):
    """
    Class for the Hello world spoke. This spoke will be in the Hello world
    category and thus on the Summary hub. It is a very simple example of
    a unit for the Anaconda's graphical user interface.

    :see: pyanaconda.ui.common.UIObject
    :see: pyanaconda.ui.common.Spoke
    :see: pyanaconda.ui.gui.GUIObject

    """

    ### class attributes defined by API ###

    # list all top-level objects from the .glade file that should be exposed
    # to the spoke or leave empty to extract everything
    builderObjects = ["helloWorldSpokeWindow", "buttonImage"]

    # the name of the main window widget
    mainWidgetName = "helloWorldSpokeWindow"

    # name of the .glade file in the same directory as this source
    uiFile = "hello_world.glade"

    # category this spoke belongs to
    category = HelloWorldCategory

    # spoke icon (will be displayed on the hub)
    # preferred are the -symbolic icons as these are used in Anaconda's spokes
    icon = "face-cool-symbolic"

    # title of the spoke (will be displayed on the hub)
    title = N_("_HELLO WORLD")</programlisting>

      <para>
        In the begining two common functions for translations are defined, but
        with the unusual definition for the <function>_</function>
        function. This is caused by the fact that our addon is not meant to have
        translations. Then we can again see the usage of the
        <varname>__all__</varname> variable to export only the spoke class
        <!--add reference to the warning?--> followed by the first lines of its
        definition including the definitions of attributes mentioned
        above. Their values are referencing the widgets defined in the
        <filename>org_fedora_hello_world/gui/spokes/hello.glade</filename> file
        included in the &HWADDON;'s sources (if you want to open the file, see
        the begining of the <xref linkend="section_deploying_and_testing"/> that
        lists the packages that are needed). Only two of the attributes deserve
        a further comment. The first one is the <varname>category</varname>
        attribute the value of which is the
        <classname>HelloWorldCategory</classname> class imported from the
        <package>org_fedora_hello_world.gui.categories</package> module. We will
        get to the <classname>HelloWorldCategory</classname> definition later,
        but for now note what was mentioned in the comment just before the
        import:

        <important>
          <para>
            The path to addons is in sys.path so things can be imported from the
            org_fedora_hello_world package.
          </para>
        </important>

        The second attribute that deserves a comment is the
        <varname>title</varname> attribute whose definition contains two
        underscores. The former one is part of the <function>N_</function>
        function name that marks the string for translation, but returns the
        non-translated version of the string (translation is done later). The
        latter one is part of the title itself and makes the spoke reachable
        from the hub with the Alt+H keyboard shortcut.
      </para>

      <para>
        What usually follows the header of the class definition and the class
        attributes definitions is the constructor that initializes an instance
        of the class. In case of the Anaconda installer's GUI objects there are
        two methods initializing a new instance &mdash; common Python's
        <methodname>__init__</methodname> method and the
        <methodname>initialize</methodname> method. The reason for two such
        functions is that the GUI objects may be created in memory at one time
        and fully initialized (which can take a longer time) at a different
        time. Thus the <methodname>__init__</methodname> method should only
        call the parent's <methodname>__init__</methodname> method and
        e.g. initialize non-GUI attributes. On the other hand the
        <methodname>initialize</methodname> method that is called when the
        installer's graphical user interface initializes should finish the full
        initialization of the spoke. This is how these two methods look in our
        case (note the number and description of the arguments passed to the
        <methodname>__init__</methodname> method):
      </para>

      <programlisting>    def __init__(self, data, storage, payload, instclass):
        """
        :see: pyanaconda.ui.common.Spoke.__init__
        :param data: data object passed to every spoke to load/store data
                     from/to it
        :type data: pykickstart.base.BaseHandler
        :param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        :type storage: blivet.Blivet
        :param payload: object storing packaging-related information
        :type payload: pyanaconda.packaging.Payload
        :param instclass: distribution-specific information
        :type instclass: pyanaconda.installclass.BaseInstallClass

        """

        NormalSpoke.__init__(self, data, storage, payload, instclass)

    def initialize(self):
        """
        The initialize method that is called after the instance is created.
        The difference between __init__ and this method is that this may take
        a long time and thus could be called in a separated thread.

        :see: pyanaconda.ui.common.UIObject.initialize

        """

        NormalSpoke.initialize(self)
        self._entry = self.builder.get_object("textEntry")</programlisting>

      <para>
        Both methods are very simple, but still there are few things deserving a
        comment. The most important one is the <varname>data</varname> parametr
        passed to the <methodname>__init__</methodname> method. It is the
        in-memory tree-like representation of the kickstart file where all the
        data is stored. In one of the ancestors'
        <methodname>__init__</methodname> methods it is stored in the
        <varname>self.data</varname> attribute so we can read and modify it in
        all other methods of the class. Since we have defined the
        <classname>HelloWorldData</classname> class in <xref
        linkend="section_kickstart_support"/> there is a subtree in
        <varname>self.data</varname> for our addon and its root (an instance of
        the <classname>HelloWorldData</classname>) is available as
        <varname>self.data.addons.org_fedora_hello_world</varname>. One of the
        other things an ancestor's <methodname>__init__</methodname> does is
        initializing an instance of the <classname>GtkBuilder</classname>
        with the spoke's <filename>.glade</filename> file and storing it as
        <varname>self.builder</varname>. This is used in the
        <methodname>initialize</methodname> method to get the
        <classname>GtkTextEntry</classname> used to show and modify the text
        from the kickstart file's %addon section.
      </para>

      <para>
        The <methodname>__init__</methodname> and
        <methodname>initialize</methodname> methods are the two methods that
        play their roles when the spoke is created. However, the main role of
        the spoke is to be visited by user who wants to change or review some
        values it shows and sets. There are three methods &mdash;
        <methodname>refresh</methodname>, <methodname>apply</methodname> and
        <methodname>execute</methodname> &mdash; that handle things that need to be
        done when the spoke is entered and left. The
        <methodname>refresh</methodname> method is called when the spoke is
        about to be visited by the user and its responsibility is to refresh the
        spoke's state (mainly it's UI elements) to reflect the current values
        stored in the <varname>self.data</varname> structure. The
        <methodname>apply</methodname> and <methodname>execute</methodname>
        methods are called when the spoke is left and they should store values
        set in the UI elements to the <varname>self.data</varname> structure and
        do all runtime changes the spoke requires based on its current state,
        respectively.
      </para>

      <para>
        The implementations of those three functions are very simple in the
        &HWADDON;:
      </para>

      <programlisting>    def refresh(self):
        """
        The refresh method that is called every time the spoke is displayed.
        It should update the UI elements according to the contents of
        self.data.

        :see: pyanaconda.ui.common.UIObject.refresh

        """

        self._entry.set_text(self.data.addons.org_fedora_hello_world.text)

    def apply(self):
        """
        The apply method that is called when the spoke is left. It should
        update the contents of self.data with values set in the GUI elements.

        """

        self.data.addons.org_fedora_hello_world.text = self._entry.get_text()

    def execute(self):
        """
        The excecute method that is called when the spoke is left. It is
        supposed to do all changes to the runtime environment according to
        the values set in the GUI elements.

        """

        # nothing to do here
        pass</programlisting>

      <para>
        So far we have covered methods that can be used to instantiate and visit
        spoke. It may seem like everything that is needed, but not every spoke
        can be visited anytime (e.g. What would be the point of software
        selection being shown before the repository is set?) and while values
        shown and controlled by some spokes are crucial to the installation
        process and cannot be omitted, some spokes allow modification of
        optional values with minor effect on the installed system. That's why
        all spokes have the <property>ready</property>,
        <property>completed</property> and <property>mandatory</property>
        properties. As their names suggest, these properties determine if the
        spoke is ready to be visited, if the spoke is completed (i.e. all values
        it requires to be set are set) and if the spoke is mandatory to be
        completed for the installation to continue. All these attributes of the
        spoke need to be dynamically determined based on the current state of
        the installer/installation process. Here comes the trivial
        implementation of those properties from the &HWADDON; which requires
        some value to be set in the <classname>HelloWorldData</classname>'s
        <varname>text</varname> attribute:
      </para>

      <programlisting>    @property
    def ready(self):
        """
        The ready property that tells whether the spoke is ready (can be visited)
        or not. The spoke is made (in)sensitive based on the returned value.

        :rtype: bool

        """

        # this spoke is always ready
        return True

    @property
    def completed(self):
        """
        The completed property that tells whether all mandatory items on the
        spoke are set, or not. The spoke will be marked on the hub as completed
        or uncompleted acording to the returned value.

        :rtype: bool

        """

        return bool(self.data.addons.org_fedora_hello_world.text)

    @property
    def mandatory(self):
        """
        The mandatory property that tells whether the spoke is mandatory to be
        completed to continue in the installation process.

        :rtype: bool

        """

        # this is an optional spoke that is not mandatory to be completed
        return False</programlisting>

      <para>
        With those three properties defined, a spoke can tell users whether they
        may, have to or cannot visit the spoke. Nevertheless, users seeing the
        hub need to decide whether to visit the spoke or not. That's why every
        spoke also has the <property>status</property> property, which is
        supposed to provide a short (one-line) summary describing values set on
        the spoke. Since the only value managed by the spoke is the text it
        shows, allows to edit and stores in the <varname>self.data</varname>
        structure, it is only logical to use that text as the status. Also, the
        status should warn user if no text is set:
      </para>

      <programlisting>    @property
    def status(self):
        """
        The status property that is a brief string describing the state of the
        spoke. It should describe whether all values are set and if possible
        also the values themselves. The returned value will appear on the hub
        below the spoke's title.

        :rtype: str

        """

        text = self.data.addons.org_fedora_hello_world.text

        # If --reverse was specified in the kickstart, reverse the text
        if self.data.addons.org_fedora_hello_world.reverse:
            text = text[::-1]

        if text:
            return _("Text set: %s") % text
        else:
            return _("Text not set")</programlisting>

      <para>
        And that's it! Less than 60 lines of code (the real code lines) are
        needed to implement the basic GUI of an addon. Of course, it is a
        trivial addon that does nothing useful, but anything else is just a
        common Python Gtk programming with some minor specific restrictions. For
        example, as was mentioned in the begining of this section, every spoke
        has to have its main window &mdash; an instance of the
        <classname>SpokeWindow</classname> widget. This widget (together with
        some more Anaconda-specific widgets) exists in the
        <package>anaconda-widgets</package> package and files needed for
        development (e.g. Glade definitions) live in the
        <package>anaconda-widgets-devel</package> package.
      </para>
        </section>

        <section id="advanced_features">
          <title>Advanced features</title>
      <para>
        Because many spokes have a lot in common, the
        <package>pyanaconda</package> package contains a lot of helper and
        utility functions and constructs, that may be used by hubs and
        spokes. Majority of them are available in the
        <package>pyanaconda.ui.gui.utils</package> module. The &HWADDON;
        demonstrates usage of the utility, that is used in a number of
        Anaconda's GUI code &mdash; the <function>englightbox</function> context
        manager, that puts a window into a lightbox to make it better visible,
        focused and to prevent users from interaction with the underlying
        window. To demonstrate such functionality, the &HWADDON;'s GUI contains
        a button that runs a dialog. The dialog itself is a special class
        <classname>HelloWorldDialog</classname> inheriting from the
        <classname>GUIObject</classname> class defined in the
        <package>pyanaconda.ui.gui.__init__</package> module. The dialog class
        defines the <function>run</function> method that runs and destroys an
        internal Gtk dialog accessible through the
        <varname>self.window</varname> attribute that is populated thanks to the
        <varname>mainWidgetName</varname> class attribute with the same meaning
        as in case of the spoke. The code running the dialog within a lightbox
        is then very simple:
      </para>

      <programlisting>        # every GUIObject gets ksdata in __init__
        dialog = HelloWorldDialog(self.data)

        # show dialog above the lightbox
        with enlightbox(self.window, dialog.window):
            dialog.run()
      </programlisting>

      <para>
        The code simply creates an instance of the dialog and then uses the
        <function>enlightbox</function> context manager to run the dialog within
        a lightbox. The context manager needs a reference to the window of the
        spoke and to the dialog's window to instantiate the lightbox for them.
      </para>

      <para>
        Another useful feature of the Anaconda's codebase is a possibility to
        define a spoke that will appear in the installation process as well as
        in the first boot when the <command>Initial Setup</command> tool reusing
        the <package>pyanaconda</package> package runs. All that is needed to
        make spoke available in the <command>Initial Setup</command> is to
        inherit the special <classname>FirstbootSpokeMixIn</classname> class (or
        more precisely mixin) as the first inherited class. The other option is
        the <classname>FirstbootOnlySpokeMixIn</classname>
        <footnote>
          <para>
            both those classes are defined in the
            <package>pyanaconda.ui.common</package> module
          </para>
        </footnote>
        class/mixin which, as its name suggests, make spoke appear only in the
        <command>Initial Setup</command> utility.
      </para>

      <para>
        There are many more advanced features provided by the
        <package>pyanaconda</package> package (like the
        <emphasis>@gtk_action_wait</emphasis> and
        <emphasis>@gtk_action_nowait</emphasis> decorators), but they are out of
        scope of this guide. Readers are recommended to go through the Anaconda
        installer's sources that contain a lot of examples.
      </para>

        </section>

      </section>
      <section id="section_tui">
        <title>Textual user interface</title>

        <para>
          The <xref linkend="section_introduction"/> mentions that apart from
          the GUI installation, the Anaconda installer also supports text mode
          installation that may be the only choice on some hardware
          configurations. The previous <xref linkend="section_gui_support"/>
          describes, how it is possible for an addon to define and implement
          graphical screens for the installer allowing user interaction. Now
          it's time to have a look at the text mode which is based on the
          Anaconda's <emphasis>simpleline</emphasis> toolkit that is suitable
          for purely textual output without any "advanced" features like
          colours, fonts, cursor movement etc.
        </para>

        <para>
          Internally, there are three main classes in the
          <emphasis>simpleline</emphasis> toolkit &mdash;
          <classname>App</classname>, <classname>UIScreen</classname> and
          <classname>Widget</classname>. Widgets, which are elemental units
          containing the information to be shown (printed) to the user, are
          placed on the UIScreens that are switched by a single instance of the
          <classname>App</classname> class. On top of those basic elements there
          are hubs, spokes and dialogs all containing various widgets similarly
          as in the GUI. So from the addon's perspective, the most important
          classes are the <classname>NormalTUISpoke</classname> and various
          other classes defined in the
          <package>pyanaconda.ui.tui.spokes</package> package. All those classes
          are based on the <classname>TUIObject</classname> class which is an
          equivalent of the <classname>GUIObject</classname> class mentioned in
          the previous chapter.
        </para>

        <para>
          Creating a text spoke for an addon again means creating subpackages of
          the main addon's package. This time it has to be named <filename
          class="directory">tui</filename> and the directory for spokes has to
          be, surprisingly, named <filename
          class="directory">spokes</filename>. A TUI spoke is again a Python
          class this time inheriting from the
          <classname>NormalTUISpoke</classname> class overriding special
          arguments and methods defined by the API. Because the TUI is simpler
          than the GUI there are fewer such arguments, namely two &mdash;
          <varname>title</varname> and <varname>category</varname>. The former
          one has the same meaning and type as in the GUI case, but the latter
          one has to be a string in text mode. Categories are handled in a
          different way in the GUI and TUI code of the Anaconda installer.
          <footnote>
            <para>
              which is likely to change in the future to sticking to the better
              (GUI) way
            </para>
          </footnote>

          However, categories are used only for grouping and ordering spokes on
          hubs in the text mode (their titles are not shown anywere), so the
          easiest thing is to use some preexisting category (a new TUI category
          would require a patch for the Anaconda installer).
        </para>

        <para>
          Apart from the two arguments, the spoke class is expected to define
          (override) a few methods &mdash; <methodname>__init__</methodname>,
          <methodname>initialize</methodname>, <methodname>refresh</methodname>,
          <methodname>refresh</methodname>, <methodname>apply</methodname>,
          <methodname>execute</methodname>, <methodname>input</methodname>,
          <methodname>prompt</methodname> &mdash; and properties described in
          the <xref linkend="section_gui_support"/> for the case of a GUI
          spoke. Let's have a look on a trivial TUI spoke defined in the
          &HWADDON;. We could start with the methods:
        </para>

        <programlisting>    def __init__(self, app, data, storage, payload, instclass):
        """
        :see: pyanaconda.ui.tui.base.UIScreen
        :see: pyanaconda.ui.tui.base.App
        :param app: reference to application which is a main class for TUI
                    screen handling, it is responsible for mainloop control
                    and keeping track of the stack where all TUI screens are
                    scheduled
        :type app: instance of pyanaconda.ui.tui.base.App
        :param data: data object passed to every spoke to load/store data
                     from/to it
        :type data: pykickstart.base.BaseHandler
        :param storage: object storing storage-related information
                        (disks, partitioning, bootloader, etc.)
        :type storage: blivet.Blivet
        :param payload: object storing packaging-related information
        :type payload: pyanaconda.packaging.Payload
        :param instclass: distribution-specific information
        :type instclass: pyanaconda.installclass.BaseInstallClass

        """

        NormalTUISpoke.__init__(self, app, data, storage, payload, instclass)
        self._entered_text = ""

    def initialize(self):
        """
        The initialize method that is called after the instance is created.
        The difference between __init__ and this method is that this may take
        a long time and thus could be called in a separated thread.

        :see: pyanaconda.ui.common.UIObject.initialize

        """

        NormalTUISpoke.initialize(self)

    def refresh(self, args=None):
        """
        The refresh method that is called every time the spoke is displayed.
        It should update the UI elements according to the contents of
        self.data.

        :see: pyanaconda.ui.common.UIObject.refresh
        :see: pyanaconda.ui.tui.base.UIScreen.refresh
        :param args: optional argument that may be used when the screen is
                     scheduled (passed to App.switch_screen* methods)
        :type args: anything
        :return: whether this screen requests input or not
        :rtype: bool

        """

        self._entered_text = self.data.addons.org_fedora_hello_world.text
        return True

    def apply(self):
        """
        The apply method that is called when the spoke is left. It should
        update the contents of self.data with values set in the spoke.

        """

        self.data.addons.org_fedora_hello_world.text = self._entered_text

    def execute(self):
        """
        The excecute method that is called when the spoke is left. It is
        supposed to do all changes to the runtime environment according to
        the values set in the spoke.

        """

        # nothing to do here
        pass

    def input(self, args, key):
        """
        The input method that is called by the main loop on user's input.

        :param args: optional argument that may be used when the screen is
                     scheduled (passed to App.switch_screen* methods)
        :type args: anything
        :param key: user's input
        :type key: unicode
        :return: if the input should not be handled here, return it, otherwise
                 return True or False if the input was processed succesfully or
                 not respectively
        :rtype: bool|unicode

        """

        if key:
            self._entered_text = key

        # no other actions scheduled, apply changes
        self.apply()

        # close the current screen (remove it from the stack)
        self.close()
        return True

    def prompt(self, args=None):
        """
        The prompt method that is called by the main loop to get the prompt
        for this screen.

        :param args: optional argument that can be passed to App.switch_screen*
                     methods
        :type args: anything
        :return: text that should be used in the prompt for the input
        :rtype: unicode|None

        """

        return _("Enter a new text or leave empty to use the old one: ")</programlisting>

        <para>
          There is no need to override the <methodname>__init__</methodname>
          method if it just calls the ancestor's
          <methodname>__init__</methodname> method, but the comments in the
          example code describe the arguments passed to constructors of spoke
          classes in an understandable way. The
          <methodname>initialize</methodname> method just sets up a default
          value for the spoke's internal attribute which is then updated by the
          <methodname>refresh</methodname> method and used by the
          <methodname>apply</methodname> method to update the kickstart
          data. The only differences from the GUI equivalents of those two
          methods are the return type of the <methodname>refresh</methodname>
          method that is <type>bool</type> instead of <type>None</type> and an
          additional <varname>args</varname> argument it takes. The meaning of
          the returned value is explained in the comment &mdash; it tells the
          application (the single <classname>App</classname> class instance)
          whether that spoke requires input from user or not. The additional
          <varname>args</varname> argument is used for passing extra information
          to the spoke when it scheduled. Then there is also the
          <methodname>execute</methodname> method with the same purpose as in
          the GUI and with the same <emphasis>pass</emphasis> statement doing
          all that is needed in such a trivial case.
        </para>

        <para>
          The <methodname>input</methodname> and <methodname>prompt</methodname>
          methods are TUI-specific and as thier names suggest they are
          responsible for interaction with the user. The
          <methodname>prompt</methodname> method should simply return the prompt
          that should be printed once the content of the spoke is printed. After
          a user enters some string in a reaction to the prompt, the entered
          string is passed to the <methodname>input</methodname> method for
          processing. The <methodname>input</methodname> method usually needs to
          parse the input and take some actions based on its type and
          value. Since our spoke just asks for some value, the value is simply
          stored in an internal attribute. But typically there are some
          non-trivial actions done like accepting the 'c' or 'r' inputs for
          continuing or refreshing, respectively, converting numbers into
          integers and showing additional screens or toggling bool values based
          on them etc. In contrast to the GUI code, the
          <methodname>apply</methodname> method is not called automatically when
          leaving the spoke, so we need to call it explicitly from the
          <methodname>input</methodname> method. The same applies to closing
          (hiding) the spoke's screen done by calling the
          <methodname>close</methodname> method of the spoke. If we want to show
          another screen (need some additional info from user entered in a
          different spoke, dialog, etc.) we can also instantiate another
          <classname>TUIObject</classname> here and call one of the
          <methodname>self.app.switch_screen*</methodname> methods of the
          <classname>App</classname>.  The last interesting thing about the
          <methodname>input</methodname> method is its return value. It has to
          be either <varname>INPUT_PROCESSED</varname> or
          <varname>INPUT_DISCARDED</varname> constant (both defined in the
          <package>pyanaconda.constants_text</package> module) or the input
          string itself in case such an input should be processed by some other
          screen.
        </para>

        <para>
          Since the restrictions of the text user interface are quite strong the
          TUI spokes typically have a very similar structure &mdash; a list of
          checkboxes or entries that should be (un)checked or populated by the
          user. The previous paragraphs show the imperative way of implementing
          such TUI spoke where the spoke's methods handle printing and
          processing of the available and provided data. However, there is a
          different, simpler way of doing that by using the declarative
          <classname>EditTUISpoke</classname> class from the
          <package>pyanaconda.ui.tui.spokes</package> package. By inheriting
          from this class, it is possible to implement a typical TUI spoke by
          just specifying fields and attributes that should be set on the
          spoke. The following code defines an example spoke implemented that
          way:
        </para>

        <programlisting>class _EditData(object):
    """Auxiliary class for storing data from the example EditSpoke"""

    def __init__(self):
        """Trivial constructor just defining the fields that will store data"""

        self.checked = False
        self.shown_input = ""
        self.hidden_input = ""

class HelloWorldEditSpoke(EditTUISpoke):
    """Example class demonstrating usage of EditTUISpoke inheritance"""

    title = _("Hello World Edit")
    category = "localization"

    # simple RE used to specify we only accept a single word as a valid input
    _valid_input = re.compile(r'\w+')

    # special class attribute defining spoke's entries as:
    # Entry(TITLE, ATTRIBUTE, CHECKING_RE or TYPE, SHOW_FUNC or SHOW)
    # where:
    #   TITLE specifies descriptive title of the entry
    #   ATTRIBUTE specifies attribute of self.args that should be set to the
    #             value entered by the user (may contain dots, i.e. may specify
    #             a deep attribute)
    #   CHECKING_RE specifies compiled RE used for deciding about
    #               accepting/rejecting user's input
    #   TYPE may be one of EditTUISpoke.CHECK or EditTUISpoke.PASSWORD used
    #        instead of CHECKING_RE for simple checkboxes or password entries,
    #        respectively
    #   SHOW_FUNC is a function taking self and self.args and returning True or
    #             False indicating whether the entry should be shown or not
    #   SHOW is a boolean value that may be used instead of the SHOW_FUNC
    #
    #   :see: pyanaconda.ui.tui.spokes.EditTUISpoke
    edit_fields = [
        Entry("Simple checkbox", "checked", EditTUISpoke.CHECK, True),
        Entry("Always shown input", "shown_input", _valid_input, True),
        Entry("Conditioned input", "hidden_input", _valid_input,
              lambda self, args: bool(args.shown_input)),
        ]

    def __init__(self, app, data, storage, payload, instclass):
        EditTUISpoke.__init__(self, app, data, storage, payload, instclass)

        # just populate the self.args attribute to have a store for data
        # typically self.data or a subtree of self.data is used as self.args
        self.args = _EditData()

    @property
    def completed(self):
        # completed if user entered something non-empty to the Conditioned input
        return bool(self.args.hidden_input)

    @property
    def status(self):
        return "Hidden input %s" % ("entered" if self.args.hidden_input
                                    else "not entered")

    def apply(self):
        # nothing needed here, values are set in the self.args tree
        pass</programlisting>

        <para>
          The auxiliary class <classname>_EditData</classname> just serves as a
          data container that is used for storing values entered by the
          user. The <classname>HelloWorldEditSpoke</classname> defines a simple
          spoke with one checkbox and two entries (all of which are instances of
          the <classname>EditTUISpokeEntry</classname> class imported as the
          <classname>Entry</classname> class). The first one is shown every time
          the spoke is displayed and the second one that is shown only if there
          is some non-empty value set in the first one. The comments in the
          example code should be enough explanatory to guide reader through the
          declarative definition of a TUI spoke by using the
          <classname>EditTUISpoke</classname> class.
        </para>
      </section>
    </section>

    <section id="section_deploying_and_testing">
      <title>Deploying and testing an Anaconda addon</title>
      <para>
        As was mentioned in the previous section, there are some packages
        required for development of an Anaconda addon. In particular the
        <package>anaconda-widgets</package> and
        <package>anaconda-widgets-devel</package> packages that contain the
        widgets, glade specifications etc. and the <package>anaconda</package>
        package that contains the <package>pyanaconda</package> Python package
        (needed for running pylint checks and so on).
      </para>

      <para>
        To test a newly created addon one needs to put it in the installation
        environment and let the Anaconda installer collect addon's classes and
        definitions. Addons are collected from the <filename
        class="directory">/usr/share/anaconda/addons/</filename> directory, that
        is expected to contain addons' Python packages (directory trees). The
        easiest way to achieve that is to create the <filename
        class="directory">usr/share/anaconda/addons/</filename> directory tree
        somewhere, place a copy of the addon's package into it and then run the
        following command:
      </para>

      <programlisting>$ find . |cpio -c -o |gzip -9 > addon_updates.img</programlisting>

      <para>
        The result is a gzipped cpio archive, but at the same time a so-called
        <emphasis>updates image</emphasis> that can be uploaded to a web server
        or copied to a USB drive and used to update the installation
        environment. If a boot option formatted as
        <emphasis>"updates=UPDATES_IMAGE_URL"</emphasis> is used when booting
        into the installer, Anaconda fetches the updates image, and unpacks it
        to the installation environment.

        <footnote>
          <para>
            overwriting the files that already exist with the files from the
            updates image (which is how the Anaconda developers use those files
            for testing patches)
          </para>
        </footnote>

        If everything goes well, all addon's classes are collected by the
        installer, the kickstart section (if any) is passed to the addon to
        process, spokes are shown on the hub etc.
      </para>

      <para>
        Once an addon is tested and ready to be deployed it should be packaged
        as a Fedora package <!-- link to the packaging guide --> to facilitate
        creation of the installation images containing the addon (so-called
        <emphasis>composes</emphasis> <indexterm id="compose"> <primary> compose
        </primary> </indexterm>. That requires writing a so-called
        <emphasis>spec</emphasis><indexterm id="spec"> <primary> spec </primary>
        </indexterm> file which defines and describes an RPM package. The basic
        structure of an addon spec file may look like this:
      </para>
      <programlisting>Name:           example-anaconda-addon
Version:        0.1
Release:        1%{?dist}
Summary:        Anaconda addon useful for something in the installation process

License:        GPLv2+
URL:            https://git.fedorahosted.org/cgit/example-anaconda-addon.git

Source0:        %{name}-%{version}.tar.gz

BuildArch:      noarch
BuildRequires:	python2-devel
BuildRequires:  anaconda >= 19
Requires:       anaconda >= 19

%description
This is an addon that brings some useful additional functionality to the
Anaconda installer.

%prep
%setup -q

%build

%check
make test

%install
make install DESTDIR=%{buildroot}

%files
%{_datadir}/anaconda/addons/org_fedora_example

%doc COPYING ChangeLog README

%changelog
* Mon Jan 6 2014 Great Author &lt;great.author@example.com&gt; - 0.1-1
- Initial RPM for the example-anaconda-addon</programlisting>

      <para>
        Such spec file makes use of the <command>make</command> utility with the
        following example Makefile: <indexterm id="Makefile"> <primary> Makefile
        </primary> </indexterm>
      </para>
      <programlisting>NAME = example-anaconda-addon

VERSION = 0.1

ADDON = org_fedora_example
TESTS = tests

FILES = $(ADDON) \
	$(TESTS) \
	COPYING \
	Makefile \
	README

EXCLUDES = \
	*.pyc

all:
	@echo "usage: make dist"
	@echo "       make test"
	@echo "       make install"
	@echo "       make uninstall"

DISTNAME = $(NAME)-$(VERSION)
ADDONDIR = /usr/share/anaconda/addons/
DISTBALL = $(DISTNAME).tar.gz

install:
	mkdir -p $(DESTDIR)$(ADDONDIR)
	cp -rv $(ADDON) $(DESTDIR)$(ADDONDIR)

uninstall:
	rm -rfv $(DESTDIR)$(ADDONDIR)

dist:
	rm -rf $(DISTNAME)
	mkdir -p $(DISTNAME)
	@if test -d ".git"; \
	then \
		echo Creating ChangeLog &amp;&amp; \
		( cd "$(top_srcdir)" &amp;&amp; \
		  echo '# Generate automatically. Do not edit.'; echo; \
		  git log --stat --date=short ) > ChangeLog.tmp \
		&amp;&amp; mv -f ChangeLog.tmp $(DISTNAME)/ChangeLog \
		|| ( rm -f ChangeLog.tmp ; \
		     echo Failed to generate ChangeLog >&amp;2 ); \
	else \
		echo A git clone is required to generate a ChangeLog >&amp;2; \
	fi
	for file in $(FILES); do \
		cp -rpv $$file $(DISTNAME)/$$file; \
	done
	for excl in $(EXCLUDES); do \
		find $(DISTNAME) -name "$$excl" -delete; \
	done
	tar -czvf $(DISTBALL) $(DISTNAME)
	rm -rf $(DISTNAME)

test:
	PYTHONPATH=. nosetests --processes=-1 -vw tests/</programlisting>

      <!--
        Which packages are needed? How to deploy and test an Anaconda addon on
        the running system?
      -->
    </section>

    <section id="section_final_words">
      <title>Addons welcomed</title>
      <para>
        As has been described in the <xref linkend="section_introduction" />,
        there are many things that could be added to the Anaconda installer to
        facilitate installation and configuration of the operating system. This
        guide is supposed to be the first place to start the adventure of
        Anaconda addon development and hopefully it shows it's quite easy and
        peaceful to write a brand new piece of an OS installer. Apart from the
        trivial &HWADDON; there exists the <ulink
        url="https://fedorahosted.org/oscap-anaconda-addon">OSCAP Anaconda
        Addon</ulink> <indexterm id="oscap_addon"><primary>OSCAP Anaconda
        Addon</primary></indexterm> project that may be used as a source of
        additional information, tips and patterns useful for addon
        development. Hopefully there will soon be more addons created by various
        developers coming from various projects.
      </para>

      <para>
        This guide and the examples of addons are definitely not covering 100 %
        of the trick&amp;treat game of Anaconda addon development. However,
        members of the Anaconda installer team (and in particular Vratislav
        Podzimek), are always willing to help addon developers with their
        questions and issues. The best place to ask is the <ulink
        url="https://www.redhat.com/mailman/listinfo/anaconda-devel-list">
        anaconda-devel</ulink><indexterm id="anaconda_devel"> <primary>
        anaconda-devel-list</primary> </indexterm> mailing list that is read
        and moderated by the Anaconda developers.
      </para>

      <para>
        If there is a nice feature that should be added to the Anaconda
        installer's codebase and API or if there is a bug, please send tested
        patches and pylint-checked

        <footnote>
          <para>
            to facilitate testing and pylint checks, the <command>make
            check</command> command may be used to run tests and checks with
            quite effective false-positives handling
          </para>
        </footnote>

        patches to the <ulink
        url="https://lists.fedorahosted.org/pipermail/anaconda-patches/">anaconda-patches</ulink>
        <indexterm id="anaconda_patches"> <primary> anaconda-patches-list
        </primary> </indexterm>mailing list for a review. If accepted, one of
        the developers will push the patches to the Anaconda's git repository.
      </para>

      <para>
        Keep in mind, <emphasis>addons and patches welcomed!</emphasis>
      </para>
        <!--
            The FAQ section will be added based on the initial feedback and
            actual FAQs
        -->
    </section>

    <xi:include href="Revision_History.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
    <index />
</article>

