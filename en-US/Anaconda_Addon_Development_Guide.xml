<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "Anaconda_Addon_Development_Guide.ent">
%BOOK_ENTITIES;
]>
<article status="draft">
    <xi:include href="Article_Info.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
    <section id="section_introduction">
      <title>Introduction</title>
      <para>
        The Anaconda is the operating system installer (OS) used in &FEDORA;,
        &RHEL; and their derivatives. From closer look it is a set of python
        modules and scripts together with some additional files like Gtk widgets
        (written in C), systemd units and dracut libraries. Altogether they form
        a tool that allows user to set parameters of the resulting (target)
        system and then set such system up on a machine. The final installation
        process has four major steps:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            installation destination preparation (usually disk partitioning)
          </para>
        </listitem>
        <listitem>
          <para>
            package and data installation
          </para>
        </listitem>
        <listitem>
          <para>
            boot loader installation and configuration
          </para>
        </listitem>
        <listitem>
          <para>
            configuration of the newly installed system
          </para>
        </listitem>
      </itemizedlist>

      <para>
        There are three ways how the user can set parameters for the target
        system (and in some cases also for the installation process). The most
        commonly used one is the graphical user interface (GUI) which should
        cover all common use cases and should be clear and easily understandable
        even for a non-advanced user. Although Anaconda supports also
        installation over VNC there are some corner cases where a textual
        interface is needed and some of these cases are installations over
        serial consoles on "exotic" pieces of hardware. For this reason Anaconda
        also has a textual user interface (TUI) that works basically the same
        way as a black only line printer (because of the various serial consoles
        not supporting cursor movement, colors and other "advanced"
        features). Text mode installation implements only most important
        features of the graphical installation and usually needs to be combined
        with the command line arguments passed to the Anaconda installer because
        it doesn't provide all options GUI provides. The third way to set the
        installation parameters and the most advanced one is a kickstart
        file. It is a simple file with command-like syntax that can contain data
        driving the installation process that runs automatically unless the
        kickstart file doesn't contain all data needed in which case UI asks
        user about the missing pieces. More info about kickstarts can be found
        at <ulink url="http://fedoraproject.org/wiki/Anaconda/Kickstart">the
        Anaconda/Kickstart wiki page</ulink>. Addons related kickstart
        specifications are covered in <xref linkend="section_addon_structure"/>.
        Important fact is that while TUI is not full-featured mode of the
        installation, kickstart installation provides the highest number of
        configuration options. The golden rule is that everything has to be
        supported in kickstart first. Then GUI and TUI pieces can come
        supporting subsets of configuration options provided in kickstart that
        allow to keep user interface (UI) clear and non-confusing. All in all
        Anaconda has to be simple but at the same time complex which is always
        hard to achieve.
      </para>

      <para>
        As it is probably obvious there are many things that need to be happen
        during the installation process. And for many teams and individuals it
        seems to be a good idea to add more things to the OS installer so that
        the target system can be pre-configured before it is run for the first
        time. On one hand the installation environment is quite specific and
        commonly used tools are usually not ready to work in it, but on the
        other hand once something can be configured via kickstart multiple
        systems with the same configuration can be installed easily. However the
        more code the installer the more bugs it contains. Moreover the
        maintenance becomes harder and harder with every new functionality and
        it is harder and harder to follow changes in so many areas. So because
        of all these reasons it was decided that when doing a major rewrite of
        the Anaconda installer, support for addons has to be added to allow
        other teams and individuals participate with their pieces of code
        developed and maintained by them as experts in their particular areas of
        interest. This guide should be one of the tools lowering the barrier to
        understanding how the Anaconda installer works and looks like internally
        and how its functionality can be extended with an addon.
      </para>

      <para>
        Traditionally the first boot of the newly installed system is also being
        considered to be a part of the installation procedure as some
        configuration of the system (e.g. users creation) is taking place at
        that point. For many years there has been a graphical tool called <ulink
        url="http://fedoraproject.org/wiki/FirstBoot">Firstboot</ulink> that has
        helped user configure some aspects of the newly installed
        system. Problem with Firstboot is that it is using Gtk2 and pygtk module
        which are both no longer developed so it needs a rewrite too. Since the
        goal was to provide every options from Firstboot already during the
        installation process it was obvious that the rewritten Firstboot should
        be sharing the code with the Anaconda installer. At the same time it was
        obvious that the old Firstboot had to be kept working because of the
        third-party modules written for it. That is how new tool called <ulink
        url="http://fedoraproject.org/wiki/Features/NewFirstboot"> Initial
        Setup</ulink> was born. It is reusing a lot of code from the Anaconda
        installer, it has the same model and design as the installer and it
        reads data produced by the installer to show values set during the
        installation process. And the great thing is that only a little is
        needed for an Anaconda addon to become an Initial Setup addon. We will
        get to this in detail in <xref linkend="section_writing_addon"/>.
      </para>

      <para>
        Some additional information about the Anaconda installer can be found at
        <ulink url="http://fedoraproject.org/wiki/Anaconda">the Anaconda wiki
        page</ulink>.
      </para>
    </section>

    <section id="section_architecture">
      <title>Architecture</title>
      <para>
        As has been already mentioned the Anaconda installer is a set of python
        modules and scripts. It of course also uses a lot of external packages
        and libraries some of which were originally created specifically for the
        needs of the installer. Major components of the whole tool are the
        following packages: <package>pykickstart</package>,
        <package>yum</package>, <package>blivet</package> and
        <package>pyanaconda</package>. <package>pykickstart</package> is a
        package that parses and validates the kickstart file (if provided) and
        also provides a data structure that Anaconda uses to store values
        driving the installation. We will focus more on the data representation
        and life cycle in the following paragraph. <package>yum</package> is the
        core python package of the <command>yum</command> package
        manager. Anaconda uses it for operations with package repositories and
        for package installation. <package>blivet</package> is a new separate
        project that used to be an internal part of the
        <package>pyanaconda</package> package as
        <package>pyanaconda.storage</package>. As the old name suggests it is a
        package that operates on the disks, mount points and all related aspects
        of the installation destination preparation. Moreover it provides
        functions for boot loader installation and configuration. The most
        important package is <package>pyanaconda</package>. It glues all the
        other components together, contains all the UI code and many modules for
        things that are not handled somewhere else &mdash; e.g. keyboard,
        timezone, network and users configuration and also a number of utility
        and system oriented functions. There is also he
        <package>python-meh</package> package that contains an exception handler
        that gathers and stores additional information from the system in case
        of a crash and passes this data to the <package>libreport</package>
        library (which is a part of the <ulink
        url="https://fedorahosted.org/abrt/">ABRT project</ulink>).
      </para>

      <!-- divide into subsections? -->
      <para>
        Life cycle of the data in the installation process is simple and
        straightforward. In the beginning if kickstart file is given to the
        installer, it is parsed and processed by the
        <package>pykickstart</package> module to become an in-memory treelike
        structure. If no kickstart file is given, and empty treelike structure
        is created. Items in that structure are then updated with the user's
        choices from the UI. Next step is the installation process which is
        driven by the values stored in that structure and finally all such
        values are written out as a new kickstart file that can be used to
        perform another installation with the same configuration. Elements of
        the structure are defined in the <package>pykickstart</package> package,
        but some of them are overridden by modified versions from the
        <package>pyanaconda.kickstart</package> module. The important fact and
        rule is that there is no other place to store configuration data and the
        installation process is data driven and as much transactional as
        possible. This neatly enforces some nice features:
      </para>
      <itemizedlist mark="bullet">
        <listitem>
          <para>
            everything has to be supported in kickstart first (because in
            automated installation only the transaction happens),
          </para>
        </listitem>
        <listitem>
          <para>
            there is a single and obvious point where underlying machine starts
            to be modified (begging of the transaction) and
          </para>
        </listitem>
        <listitem>
          <para>
            everything set in the UI is reflected in the resulting kickstart file.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        What does it mean that the installation is data driven? It means that
        the installation (and configuration) logic lies in the methods of the
        items in the treelike structure. Every item is set up (the
        <methodname>setup</methodname> method) to modify the runtime enviroment
        of the installation (if needed) and then executed (the
        <methodname>execute</methodname>) to do the changes on the newly
        installed system. We will look at these methods closer in
        <xref linkend="section_writing_addon"/>.
      </para>
    </section>

    <section id="section_hub_and_spoke">
      <title>Hub&amp;Spoke model</title>
      <para>
        What is the Anaconda's basic UI model? Why this model? Pros and cons of
        the model. What elements Anaconda's UI consists of? How does the UI work
        with the installation data? How this works in text mode?
      </para>
    </section>

    <section id="section_threads_and_communication">
      <title>Threads and communication</title>
      <para>
        Why is Anaconda multi-thread? What should be run in a separate thread?
        How does internal communication work? What are the dangerous actions
        with threads and Gtk and what Anaconda provides to overcome them?
      </para>
    </section>

    <section id="section_addon_structure">
      <title>Addon structure</title>
      <para>
        What is the basic structure of an Anaconda addon? Which parts it has to
        define and which are optional?
     </para>
    </section>

    <section id="section_writing_addon">
      <title>Writing an Anaconda addon</title>
      <para>
        Which packages are needed? Hello world addon example built step by step
        with comments and API description. Coding style. Comments on the
        "advanced features" provided by Anaconda. What is needed for an
        installer addon to become an Initial Setup addon?
      </para>
    </section>

    <section id="section_deploying_and_testing">
      <title>Deploying and testing an Anaconda addon</title>
      <para>
        How to deploy and test an Anaconda addon? On the running system vs. with
        the installation image. How should be an addon delivered? Packaging and
        basic structure for the .spec file.
      </para>
    </section>

    <section id="section_final_words">
      <title>Addons welcomed</title>
      <para>
        Where to find help with the development? Additional documentation and
        referential addon implementations? FAQ. Few words to encourage.
      </para>
    </section>

    <xi:include href="Revision_History.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
    <index />
</article>

